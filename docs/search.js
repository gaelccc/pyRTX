window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pyRTX", "modulename": "pyRTX", "kind": "module", "doc": "<p>pyRTX - Non-gravitational forces modelling using raytracing</p>\n"}, {"fullname": "pyRTX.constants", "modulename": "pyRTX.constants", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.constants.c", "modulename": "pyRTX.constants", "qualname": "c", "kind": "variable", "doc": "<p></p>\n", "default_value": "299792.458"}, {"fullname": "pyRTX.constants.stefan_boltzmann", "modulename": "pyRTX.constants", "qualname": "stefan_boltzmann", "kind": "variable", "doc": "<p></p>\n", "default_value": "5.670367e-08"}, {"fullname": "pyRTX.constants.au", "modulename": "pyRTX.constants", "qualname": "au", "kind": "variable", "doc": "<p></p>\n", "default_value": "149597870.7"}, {"fullname": "pyRTX.constants.unit_conversions", "modulename": "pyRTX.constants", "qualname": "unit_conversions", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;m&#x27;: 0.001, &#x27;km&#x27;: 1.0}"}, {"fullname": "pyRTX.defaults", "modulename": "pyRTX.defaults", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.defaults.dFloat", "modulename": "pyRTX.defaults", "qualname": "dFloat", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;float32&#x27;"}, {"fullname": "pyRTX.defaults.dInt", "modulename": "pyRTX.defaults", "qualname": "dInt", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;int32&#x27;"}, {"fullname": "pyRTX.helpers", "modulename": "pyRTX.helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.helpers.get_download_agent", "modulename": "pyRTX.helpers", "qualname": "get_download_agent", "kind": "function", "doc": "<p>Is wget installed? This helper function returns the download program available in the system.\nThis function is used for automated download of 'example data'\nParameters:</p>\n\n<p>Returns:\nagent: [str] 'wget' if wget is installed, 'curl' otherwise</p>\n\n<p>To Do:\nCurrently this function works only with UNIX/macOS systems. Expand it to windows systems</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes", "modulename": "pyRTX.classes", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere", "modulename": "pyRTX.classes.Atmosphere", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram", "kind": "class", "doc": "<p>An utility class for providing a python interface to VenusGram2005</p>\n\n<p>Requirements:</p>\n\n<ul>\n<li>python3</li>\n<li>numpy</li>\n<li>spiceypy</li>\n<li>A compiled version of VenusGram2005   </li>\n</ul>\n\n<p>Note: This version has been tested only on UNIX machines</p>\n\n<p>The intended usage:</p>\n\n<p>vg = VenusGram()\nrho, T = vg.compute(epoch, lat, lon, height, inputUnits = 'deg')</p>\n\n<p>Parameters:\n*all these patameters can be either float or numpy  arrays of floats\nepoch: epoch output of spiceypy.str2et [The epoch must be provided in TDB. This can be changed modyfying 'epoch_converter' sub]\nlat: latitude in the units specified in inputUnits\nlon: longitude in the units specified in inputUnits\nheight: height above the reference ellipsoid [km]</p>\n\n<p>Returns:\nrho: density in kg/m3\nT:   temperature in K</p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.__init__", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.__init__", "kind": "function", "doc": "<p>Initialize the istance of the class</p>\n\n<p>Parameters:\ndataFolder: [str] the path to the data folder of VenusGram2005\nexecFolder: [str] the path to where the venusgrm_V05.x executable is\ntmpFolder:  [str] the path to create a temporary convenience folder for Vgram input/output caching. Defaults to ./tmp</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataFolder</span><span class=\"o\">=</span><span class=\"s1\">&#39;/home/cascioli/VenusGram2005/&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">execFolder</span><span class=\"o\">=</span><span class=\"s1\">&#39;/home/cascioli/VenusGram2005/&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tmpFolder</span><span class=\"o\">=</span><span class=\"s1\">&#39;./tmp&#39;</span></span>)</span>"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.lstFile", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.lstFile", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.outFile", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.outFile", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.tmpFolder", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.tmpFolder", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.execFolder", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.execFolder", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.dataFolder", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.dataFolder", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.namelistWriter", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.namelistWriter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">lat</span>, </span><span class=\"param\"><span class=\"n\">lon</span>, </span><span class=\"param\"><span class=\"n\">height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.epoch_converter", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.epoch_converter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">inputFormat</span><span class=\"o\">=</span><span class=\"s1\">&#39;TDB&#39;</span>, </span><span class=\"param\"><span class=\"n\">outputformat</span><span class=\"o\">=</span><span class=\"s1\">&#39;UTC&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.readResults", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.readResults", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.readVariabilities", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.readVariabilities", "kind": "function", "doc": "<p>Read results on variables with variabilities (e.g. Density)</p>\n\n<p>Input:\nkind : [str] The requested variable (available: Density)</p>\n\n<p>Output:</p>\n\n<p>low : [float] Variable low range\navg : [float] Variable average range\nhig : [float] Variable high range</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">kind</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Atmosphere.VenusGram.compute", "modulename": "pyRTX.classes.Atmosphere", "qualname": "VenusGram.compute", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">lat</span>, </span><span class=\"param\"><span class=\"n\">lon</span>, </span><span class=\"param\"><span class=\"n\">height</span>, </span><span class=\"param\"><span class=\"n\">inputUnits</span><span class=\"o\">=</span><span class=\"s1\">&#39;deg&#39;</span>, </span><span class=\"param\"><span class=\"n\">variabilities</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Drag", "modulename": "pyRTX.classes.Drag", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag", "modulename": "pyRTX.classes.Drag", "qualname": "Drag", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.__init__", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.__init__", "kind": "function", "doc": "<p>Initialize the Drag instance</p>\n\n<p>Parameters:\nSpacecraft: Spacecraft object\ncrossectionLUT: str or LookupTableND\ndensity: function that takes as input the height and returns the density in kg/km**2\nCD: [float] the object CD</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacecraft</span>, </span><span class=\"param\"><span class=\"n\">crossectionLUT</span>, </span><span class=\"param\"><span class=\"n\">density</span>, </span><span class=\"param\"><span class=\"n\">CD</span>, </span><span class=\"param\"><span class=\"n\">body</span>, </span><span class=\"param\"><span class=\"n\">precomputation</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.classes.Drag.Drag.scName", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.scName", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.scFrame", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.scFrame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.sp_data", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.LUT", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.LUT", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.density", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.density", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.body", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.body", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.CD", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.CD", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Drag.Drag.compute", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.compute", "kind": "function", "doc": "<p>Method to compute the drag acceleration.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epochs: list of epochs</li>\n<li>ncores: number of cores to use for parallel computations</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Drag.Drag.run", "modulename": "pyRTX.classes.Drag", "qualname": "Drag.run", "kind": "function", "doc": "<p>Compute the drag at epoch in the spacecraft body frame</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.LookUpTable", "modulename": "pyRTX.classes.LookUpTable", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable", "kind": "class", "doc": "<p>This class is used to store results in the shape aof a lookup table.\nThis is mainly used to store the results of a set of raytracing results\nexample: the solar pressure for a body is computed for a grid of RA/DEC values.\nthese values can be stored in the LookupTable object and later retrieved.\nThis class offers the possibility of not oly retrieving pre-computed values, but\nalso interpolating between grid points.</p>\n\n<p>NOTE: the grid of the lookup table does not need to be regular\nthe interpolation is based on numpy griddata method which is able to cope\nwith unstructured grids</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.__init__", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span>)</span>"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.moving_frames", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.moving_frames", "kind": "variable", "doc": "<p>Returns the list of frames wich are NOT fixed wrt spacecraft body-frame.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.data", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.data", "kind": "variable", "doc": "<p>Returns the xarray data.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.attrs", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.attrs", "kind": "variable", "doc": "<p>Returns the xarray attributes.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.axes", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.axes", "kind": "variable", "doc": "<p>Returns the xarray axes values.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.base_frame", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.base_frame", "kind": "variable", "doc": "<p>Returns the spacecraft body-frame.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.ref_epc", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.ref_epc", "kind": "variable", "doc": "<p>Returns the reference epoch of the LUT.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.eul_set", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.eul_set", "kind": "variable", "doc": "<p>Returns the euler set used for the computations.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.eul_idxs", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.eul_idxs", "kind": "variable", "doc": "<p>Returns the euler set used for the computations.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.dims", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.dims", "kind": "variable", "doc": "<p>Returns the dimension axes of the xarray.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.units", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.units", "kind": "variable", "doc": "<p>Returns the units of the xarray values.</p>\n"}, {"fullname": "pyRTX.classes.LookUpTable.LookUpTable.query", "modulename": "pyRTX.classes.LookUpTable", "qualname": "LookUpTable.query", "kind": "function", "doc": "<p>Query the look up table for a given epoch, ra, dec (in degrees).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">ra</span>, </span><span class=\"param\"><span class=\"n\">dec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.PixelPlane", "modulename": "pyRTX.classes.PixelPlane", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.__init__", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.__init__", "kind": "function", "doc": "<p>\"Generate a pixel array for raytracing ad defined in Li et al., 2018\nThis is the \"optimized version\". To explicitly see the algorithm refer to the function definition\nwithout _opt extension.\nParameters:\nd0: [float] Distance of the pixel array from the center (in meters)\nlat: [float] Latitude of the pixel array center (in rad)\nlon: [float] Longitude of the pixel array center (in rad)\nwidth: [float] The width of the plane(in meters). Default = 1\nheight: [float] the height of the plane(in meters). Default = 1\nray_spacing: [float] the spacing of the rays (in meters). Default = 0.1\npackets: [int] the number of 'ray packets' to return. This is implemented to avoid the segmentation\n         fault triggered by the raytracer when the number of rays is too high</p>\n\n<p>Returns:\nlocs: [numpy array (n_rays, 3)] Pixel locations as a numpy array\ndirs: [numpy array (n_rays, 3)] the ray directions as a numpy array</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spacecraft</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;Fixed&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">lon</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ray_spacing</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">packets</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">units</span><span class=\"o\">=</span><span class=\"s1\">&#39;m&#39;</span></span>)</span>"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.mode", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.mode", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.spacecraft", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.spacecraft", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.d0", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.d0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.lon", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.lon", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.lat", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.lat", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.packets", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.packets", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.ray_spacing", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.ray_spacing", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.norm_factor", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.norm_factor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.source", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.source", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.sp_data", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.dump", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.dump", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.PixelPlane.PixelPlane.update_latlon", "modulename": "pyRTX.classes.PixelPlane", "qualname": "PixelPlane.update_latlon", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">lon</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">lat</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet", "modulename": "pyRTX.classes.Planet", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.__init__", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.__init__", "kind": "function", "doc": "<p>A class to represent the albedo, emissivity and temperature grid of a planet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.attrs", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.attrs", "kind": "variable", "doc": "<p>Returns the xarray attributes.</p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.axes", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.axes", "kind": "variable", "doc": "<p>Returns the xarray axes values.</p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.frame", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.frame", "kind": "variable", "doc": "<p>Returns the name of the grid-fixed frame.</p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.dims", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.dims", "kind": "variable", "doc": "<p>Returns the dimension axes of the xarray.</p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.periodicity", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.periodicity", "kind": "variable", "doc": "<p>Returns the property of the grid (temperature / albedo / emissivity).</p>\n"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.get_data", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.get_data", "kind": "function", "doc": "<p>Returns the xarray data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.save", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.save", "kind": "function", "doc": "<p>Method to save precomputed x-array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">complev</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.PlanetGrid.plot", "modulename": "pyRTX.classes.Planet", "qualname": "PlanetGrid.plot", "kind": "function", "doc": "<p>Implement a method to plot the grid at a specific epoch.</p>\n\n<p>Input: </p>\n\n<ul>\n<li>spiceypy epoch</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.EmissivityGrid", "modulename": "pyRTX.classes.Planet", "qualname": "EmissivityGrid", "kind": "class", "doc": "<p></p>\n", "bases": "PlanetGrid"}, {"fullname": "pyRTX.classes.Planet.EmissivityGrid.__init__", "modulename": "pyRTX.classes.Planet", "qualname": "EmissivityGrid.__init__", "kind": "function", "doc": "<p>A class to represent the emissivity grid of a planet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "pyRTX.classes.Planet.AlbedoGrid", "modulename": "pyRTX.classes.Planet", "qualname": "AlbedoGrid", "kind": "class", "doc": "<p></p>\n", "bases": "PlanetGrid"}, {"fullname": "pyRTX.classes.Planet.AlbedoGrid.__init__", "modulename": "pyRTX.classes.Planet", "qualname": "AlbedoGrid.__init__", "kind": "function", "doc": "<p>A class to represent the albedo grid of a planet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "pyRTX.classes.Planet.TemperatureGrid", "modulename": "pyRTX.classes.Planet", "qualname": "TemperatureGrid", "kind": "class", "doc": "<p></p>\n", "bases": "PlanetGrid"}, {"fullname": "pyRTX.classes.Planet.TemperatureGrid.__init__", "modulename": "pyRTX.classes.Planet", "qualname": "TemperatureGrid.__init__", "kind": "function", "doc": "<p>A class to represent the temperature grid of a planet.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "pyRTX.classes.Planet.TemperatureGrid.get_albedo", "modulename": "pyRTX.classes.Planet", "qualname": "TemperatureGrid.get_albedo", "kind": "function", "doc": "<p>Method to get the albedo value</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"nb\">dir</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.TemperatureGrid.get_emissivity", "modulename": "pyRTX.classes.Planet", "qualname": "TemperatureGrid.get_emissivity", "kind": "function", "doc": "<p>Method to get the emissivity value</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"nb\">dir</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.TemperatureGrid.compute", "modulename": "pyRTX.classes.Planet", "qualname": "TemperatureGrid.compute", "kind": "function", "doc": "<p>Implement a compute method to calculate the temperature grid in the sun-fixed frame\n(X-axis pointing the Sun).</p>\n\n<p>Input: </p>\n\n<ul>\n<li>list of epochs</li>\n<li>Latitude/Longitude step in degree</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">step</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet", "modulename": "pyRTX.classes.Planet", "qualname": "Planet", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.__init__", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.__init__", "kind": "function", "doc": "<p>A class to represent a planet/moon</p>\n\n<p>Input:\nfromFile : put here an obj file if requested to build the model. If None (default) a sphere with radius defined in \"radius\" will be built\nradius : (float) the radius of the planet. Not used if \"fromFile\" is not None\nname : (str) the name of the planet\nbodyFrame: (str) the planet body fixed frame\nsunFixedFrame: (str) the body centered - sun fixed frame\nunits: (str) [Default: km] the measurement units defining the body (can be km or m)\nsubdivs: (int) [Default: 4] the number of subdivision for the creation of the spherical planet. Note that the number of faces will grow as function of 4 ** subdivisions, so you probably want to keep this under ~5.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fromFile</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">bodyFrame</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">sunFixedFrame</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">units</span><span class=\"o\">=</span><span class=\"s1\">&#39;km&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">subdivs</span><span class=\"o\">=</span><span class=\"mi\">4</span></span>)</span>"}, {"fullname": "pyRTX.classes.Planet.Planet.name", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.fromFile", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.fromFile", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.sunFixedFrame", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.sunFixedFrame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.numFaces", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.numFaces", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.sp_data", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.mesh", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.mesh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">translate</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">rotate</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">targetFrame</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.albedoFaces", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.albedoFaces", "kind": "function", "doc": "<p>Public method:\nReturn the idxs of the mesh faces that are needed for albedo computation at time:epoch for the spacecraft:spacectaft name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">spacecraft_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.rot_toSCframe", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.rot_toSCframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">scFrame</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.emissivityFaces", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.emissivityFaces", "kind": "function", "doc": "<p>Public method:\nReturn the idxs of the mesh faces and the temperature of each face that are needed for emissivity computation at time:epoch for the spacecraft:spacectaft name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">spacecraft_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.getFaceAlbedo", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.getFaceAlbedo", "kind": "function", "doc": "<p>Return the albedo of each face at epoch</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.getFaceTemperatures", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.getFaceTemperatures", "kind": "function", "doc": "<p>Return the temperature of each face at epoch</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.getFaceEmissivity", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.getFaceEmissivity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">sunFixedFrame</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.VFNC", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.VFNC", "kind": "function", "doc": "<p>Public method:\nReturns  V F N C rotating the planet in the sunFixedFrame at epoch epoch\nV: Vertices\nF: Faces\nN: Normals\nC: Centroids</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">sunFixedFrame</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.getScPosSunFixed", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.getScPosSunFixed", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">spacecraft_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.pxform_convert", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.pxform_convert", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pxform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Planet.Planet.dayside_temperature", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.dayside_temperature", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.nightside_temperature", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.nightside_temperature", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.gridded_temperature", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.gridded_temperature", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.albedo", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.albedo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.albedo_map", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.albedo_map", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Planet.Planet.emissivity", "modulename": "pyRTX.classes.Planet", "qualname": "Planet.emissivity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Precompute", "modulename": "pyRTX.classes.Precompute", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Precompute.Precompute", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute", "kind": "class", "doc": "<p>A Class to perform calls to spiceypy in advance.</p>\n"}, {"fullname": "pyRTX.classes.Precompute.Precompute.__init__", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.__init__", "kind": "function", "doc": "<p>Initialization method for the class.\nParams:</p>\n\n<ul>\n<li>epochs (epochs of the precomputations)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">epochs</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span>)</span>"}, {"fullname": "pyRTX.classes.Precompute.Precompute.addPosition", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.addPosition", "kind": "function", "doc": "<p>Method to precompute position vectors.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>observer body (str)</li>\n<li>target body (str)</li>\n<li>frame (str)</li>\n<li>aberration correction (str)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">observer</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;CN&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.addState", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.addState", "kind": "function", "doc": "<p>Method to precompute state vectors.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>observer body (str)</li>\n<li>target body (str)</li>\n<li>frame (str)</li>\n<li>aberration correction (str)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">observer</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;CN&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.addRotation", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.addRotation", "kind": "function", "doc": "<p>Method to precompute position vectors.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>base_frame (str)</li>\n<li>target_frame (str)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">base_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.precomputeSolarPressure", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.precomputeSolarPressure", "kind": "function", "doc": "<p>Method to perform precalculation for solar radiation pressure.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>sc: object of the class Spacecraft</li>\n<li>planet: object of the class Planet</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sc</span>, </span><span class=\"param\"><span class=\"n\">planet</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"o\">=</span><span class=\"s1\">&#39;LT+S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.precomputePlanetaryRadiation", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.precomputePlanetaryRadiation", "kind": "function", "doc": "<p>Method to perform precalculation for albedo and \nthermal infrared acceleration.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>sc: object of the class Spacecraft</li>\n<li>planet: object of the class Planet</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sc</span>, </span><span class=\"param\"><span class=\"n\">planet</span>, </span><span class=\"param\"><span class=\"n\">moving_frames</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"o\">=</span><span class=\"s1\">&#39;CN&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.precomputeDrag", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.precomputeDrag", "kind": "function", "doc": "<p>Method to perform precalculation for drag acceleration.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>sc: object of the class Spacecraft</li>\n<li>planet_name: name of the body</li>\n<li>accel_frame: frame of the acceleration</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">sc</span>,</span><span class=\"param\">\t<span class=\"n\">planet_name</span>,</span><span class=\"param\">\t<span class=\"n\">moving_frames</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">accel_frame</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">correction</span><span class=\"o\">=</span><span class=\"s1\">&#39;LT+S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.dump", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.dump", "kind": "function", "doc": "<p>Method to perform precalculation.</p>\n\n<p>Params:</p>\n\n<ul>\n<li>filename: path to xarray</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.getPosition", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.getPosition", "kind": "function", "doc": "<p>Method to get position vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">observer</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.getState", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.getState", "kind": "function", "doc": "<p>Method to get state vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">observer</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.getRotation", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.getRotation", "kind": "function", "doc": "<p>Method to get rotation matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span>, </span><span class=\"param\"><span class=\"n\">base_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target_frame</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.getArray", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.getArray", "kind": "function", "doc": "<p>Method to get precomputed array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.save", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.save", "kind": "function", "doc": "<p>Method to save precomputed array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">complev</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Precompute.Precompute.pxform_convert", "modulename": "pyRTX.classes.Precompute", "qualname": "Precompute.pxform_convert", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pxform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Radiation", "modulename": "pyRTX.classes.Radiation", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.__init__", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.__init__", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>Planet : pyRTX.classes.Planet\n        The planet object the Albedo is for\nspacecraft : pyRTX.classes.Spacecraft\n        The spacecraft object the Albedo is for</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacecraft</span>, </span><span class=\"param\"><span class=\"n\">lookup</span>, </span><span class=\"param\"><span class=\"n\">Planet</span>, </span><span class=\"param\"><span class=\"n\">precomputation</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">baseflux</span><span class=\"o\">=</span><span class=\"mf\">1361.5</span></span>)</span>"}, {"fullname": "pyRTX.classes.Radiation.Albedo.scname", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.scname", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.scFrame", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.scFrame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.Planet", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.Planet", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.sp_data", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.baseflux", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.baseflux", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.lookup", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.lookup", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Albedo.run", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.run", "kind": "function", "doc": "<p>Compute the fundamental quantities for the albedo force computation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>epoch : str or float\n        the epoch at which to compute the albedo (it can be either a string or a float)</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>normalized_fluxes : np.ndarray\n        (i.e. for each face that is responsible for albedo contribution  cos(alpha)<em>cos(theta)</em>dA/pi/r**2\ndirs: np.ndarray\n        direction of each ray relative to the SC frame\nvals : np.array\n        values of the albedo for each face of the planet</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Radiation.Albedo.compute", "modulename": "pyRTX.classes.Radiation", "qualname": "Albedo.compute", "kind": "function", "doc": "<p>Method to perform the computations for albedo acceleration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Radiation.Emissivity", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.__init__", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.__init__", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>Planet : pyRTX.classes.Planet\n        The planet object the Albedo is for\nspacecraft : pyRTX.classes.Spacecraft\n        The spacecraft object the Albedo is for</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacecraft</span>, </span><span class=\"param\"><span class=\"n\">lookup</span>, </span><span class=\"param\"><span class=\"n\">Planet</span>, </span><span class=\"param\"><span class=\"n\">precomputation</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">baseflux</span><span class=\"o\">=</span><span class=\"mf\">1361.5</span></span>)</span>"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.scname", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.scname", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.scFrame", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.scFrame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.Planet", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.Planet", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.sp_data", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.baseflux", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.baseflux", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.lookup", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.lookup", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.run", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.run", "kind": "function", "doc": "<p>Compute the fundamental quantities for the emissivity force computation\nreturns \n1) normalized fluxes (i.e. for each face that is responsible for albedo contribution\ncos(theta)<em>dA/pi/r</em>*2\n2) direction of each ray relative to the SC frame</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Radiation.Emissivity.compute", "modulename": "pyRTX.classes.Radiation", "qualname": "Emissivity.compute", "kind": "function", "doc": "<p>Method to perform the computations for albedo acceleration.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.RayTracer", "modulename": "pyRTX.classes.RayTracer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.__init__", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spacecraft</span>,</span><span class=\"param\">\t<span class=\"n\">rays</span>,</span><span class=\"param\">\t<span class=\"n\">kernel</span><span class=\"o\">=</span><span class=\"s1\">&#39;Embree&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">bounces</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.kernel", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.kernel", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.bounces", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.bounces", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.diffusion", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.diffusion", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.num_diffuse", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.num_diffuse", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.rays", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.rays", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.spacecraft", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.spacecraft", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.norm_factor", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.norm_factor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.RayTracer.RayTracer.trace", "modulename": "pyRTX.classes.RayTracer", "qualname": "RayTracer.trace", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP", "modulename": "pyRTX.classes.SRP", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow", "kind": "class", "doc": "<h1 id=\"sunshadow-class-documentation\">SunShadow Class Documentation</h1>\n\n<p>A class to compute the solar flux ratio that impacts a spacecraft, accounting for\neclipse effects from airless celestial bodies. This class simulates the shadow cast\nby a planetary body on the spacecraft and can incorporate solar limb darkening effects.</p>\n\n<h2 id=\"overview\">Overview</h2>\n\n<p>The SunShadow class performs ray-tracing calculations to determine what fraction of\nthe Sun's disk is visible from a spacecraft's perspective when partially or fully\nocculted by a planetary body. It discretizes the Sun's disk into a grid of rays and\ntraces each ray to determine if it is blocked by the intervening body.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>spacecraft : Spacecraft object, optional\n        The spacecraft object containing position and orientation information.</p>\n\n<p>body : str, optional\n        Name of the occulting body (e.g., 'Moon', 'Mars'). Used for SPICE queries.</p>\n\n<p>bodyRadius : float, optional\n        Radius of the occulting body in kilometers. Used if bodyShape is not provided.</p>\n\n<p>numrays : int, default=100\n        Number of rays across the Sun's disk diameter. Total rays = numrays^2.\n        Higher values increase accuracy but computational cost.</p>\n\n<p>sunRadius : float, default=600000 km\n        Radius of the Sun in kilometers. Default is approximate photospheric radius.</p>\n\n<p>bodyShape : Planet object or str, optional\n        Either a Planet object with mesh data, or path to a shape model file.\n        If None, uses a sphere with bodyRadius.</p>\n\n<p>bodyFrame : str, optional\n        SPICE reference frame for the body shape model orientation.</p>\n\n<p>limbDarkening : str, default='Standard'\n        Solar limb darkening model to use. Options:\n        - 'Standard': Quadratic model (most commonly used)\n        - 'Eddington': Eddington approximation model\n        - None: Uniform solar disk (no limb darkening)</p>\n\n<p>precomputation : Precompute object, optional\n        Precomputed SPICE data for faster ephemeris queries.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>sunRadius : float\n        Radius of the Sun in kilometers.</p>\n\n<p>spacecraft : Spacecraft object\n        Reference to the spacecraft object.</p>\n\n<p>body : str\n        Name of the occulting body.</p>\n\n<p>limbDarkening : str or None\n        Solar limb darkening model being used.</p>\n\n<p>pxPlane : PixelPlane object\n        Discretized representation of the Sun's disk as viewed from spacecraft.</p>\n\n<p>shape : Planet object\n        Geometric representation of the occulting body.</p>\n\n<p>sp_data : Precompute object\n        Precomputed SPICE data for ephemeris queries.</p>\n\n<h2 id=\"solar-limb-darkening-models\">Solar Limb Darkening Models</h2>\n\n<p>Solar limb darkening is the observed decrease in brightness from the center to the \nedge (limb) of the solar disk. This occurs because light from the limb travels through\nmore of the Sun's atmosphere, causing greater absorption.</p>\n\n<h2 id=\"1-standard-quadratic-model\">1. Standard (Quadratic) Model</h2>\n\n<p>The most commonly used empirical model, particularly accurate for optical wavelengths:</p>\n\n<p>I(\u03b2) = a\u2080 + a\u2081\u00b7cos(\u03b2) + a\u2082\u00b7cos\u00b2(\u03b2)</p>\n\n<p>where:</p>\n\n<ul>\n<li>\u03b2 is the angle between the ray direction and the Sun center</li>\n<li>a\u2080 = 0.3  : constant term</li>\n<li>a\u2081 = 0.93 : linear coefficient</li>\n<li>a\u2082 = -0.23: quadratic coefficient</li>\n</ul>\n\n<p>This model provides:</p>\n\n<ul>\n<li>Center-to-limb intensity ratio of ~0.6</li>\n<li>Good agreement with observations in visible spectrum</li>\n<li>Fast computation</li>\n<li>Widely validated for spacecraft applications</li>\n</ul>\n\n<p>Use when: Standard solar radiation modeling, most accurate for visible wavelengths</p>\n\n<h2 id=\"2-eddington-approximation-model\">2. Eddington Approximation Model</h2>\n\n<p>A physically-based model derived from radiative transfer theory:</p>\n\n<p>I(\u03bc) = (3/4) \u00b7 [(7/12) + (\u03bc/2) - (\u03bc\u00b2/3) + (\u03bc\u00b3/12)\u00b7ln((1+\u03bc)/\u03bc)]</p>\n\n<p>where:</p>\n\n<ul>\n<li>\u03bc = cos(\u03b2), the cosine of the heliocentric angle</li>\n</ul>\n\n<p>This model:</p>\n\n<ul>\n<li>Based on stellar atmosphere theory (Eddington 1926)</li>\n<li>Assumes gray atmosphere in radiative equilibrium</li>\n<li>More physically rigorous than empirical models</li>\n<li>Slightly more computationally expensive</li>\n<li>Better for theoretical studies</li>\n</ul>\n\n<p>Use when: Theoretical accuracy is paramount, or for consistency with \n                        astrophysical modeling conventions</p>\n\n<h2 id=\"3-no-limb-darkening-none\">3. No Limb Darkening (None)</h2>\n\n<p>Uniform solar disk assumption:</p>\n\n<p>I(\u03b2) = 1.0 (constant)</p>\n\n<p>Use when:</p>\n\n<ul>\n<li>Quick approximations needed</li>\n<li>Limb darkening effects are negligible (&lt;1% accuracy requirement)</li>\n<li>Testing or debugging purposes</li>\n</ul>\n\n<h2 id=\"methods\">Methods</h2>\n\n<p>run(epoch)\n        Compute eclipse ratio at a single epoch using ray-tracing.</p>\n\n<pre><code>    Parameters\n    ----------\n    epoch : float\n            SPICE ephemeris time (seconds past J2000).\n\n    Returns\n    -------\n    float\n            Solar flux ratio: 1.0 = full Sun visible, 0.0 = total eclipse,\n            0.0-1.0 = partial eclipse. Accounts for limb darkening if enabled.\n</code></pre>\n\n<p>compute(epochs, n_cores=None)\n        Compute eclipse ratios for multiple epochs, with optional parallelization.</p>\n\n<pre><code>    Parameters\n    ----------\n    epochs : float, list, or array\n            Single epoch or array of epochs (SPICE ephemeris times).\n    n_cores : int, optional\n            Number of CPU cores for parallel computation. Default uses all available.\n\n    Returns\n    -------\n    float or array\n            Eclipse ratio(s) corresponding to input epoch(s).\n</code></pre>\n\n<h2 id=\"algorithm-details\">Algorithm Details</h2>\n\n<ol>\n<li>Create a PixelPlane representing the Sun's disk as viewed from spacecraft</li>\n<li>Generate a grid of rays across the solar disk</li>\n<li>For each ray:\na. Check if ray direction intersects the occulting body using ray-tracing\nb. If limb darkening enabled, weight ray by intensity based on position</li>\n<li>Compute eclipse ratio as (blocked rays) / (total rays)</li>\n<li>If limb darkening: use weighted sum instead of simple count</li>\n</ol>\n\n<h2 id=\"example-usage\">Example Usage</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">pyRTX.classes.SunShadow</span> <span class=\"kn\">import</span> <span class=\"n\">SunShadow</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">spiceypy</span> <span class=\"k\">as</span> <span class=\"nn\">sp</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Initialize with standard limb darkening</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shadow</span> <span class=\"o\">=</span> <span class=\"n\">SunShadow</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">spacecraft</span><span class=\"o\">=</span><span class=\"n\">my_spacecraft</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"s1\">&#39;Moon&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">bodyRadius</span><span class=\"o\">=</span><span class=\"mf\">1737.4</span><span class=\"p\">,</span>  <span class=\"c1\"># km</span>\n<span class=\"gp\">... </span>    <span class=\"n\">numrays</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">limbDarkening</span><span class=\"o\">=</span><span class=\"s1\">&#39;Standard&#39;</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Compute at single epoch</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">epoch</span> <span class=\"o\">=</span> <span class=\"n\">sp</span><span class=\"o\">.</span><span class=\"n\">str2et</span><span class=\"p\">(</span><span class=\"s1\">&#39;2024-01-01T12:00:00&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">flux_ratio</span> <span class=\"o\">=</span> <span class=\"n\">shadow</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">(</span><span class=\"n\">epoch</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;Visible solar flux: </span><span class=\"si\">{</span><span class=\"n\">flux_ratio</span><span class=\"o\">*</span><span class=\"mi\">100</span><span class=\"si\">:</span><span class=\"s2\">.1f</span><span class=\"si\">}</span><span class=\"s2\">%&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Compute over time series</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">epochs</span> <span class=\"o\">=</span> <span class=\"n\">sp</span><span class=\"o\">.</span><span class=\"n\">str2et</span><span class=\"p\">([</span><span class=\"s1\">&#39;2024-01-01T</span><span class=\"si\">{:02d}</span><span class=\"s1\">:00:00&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">h</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">24</span><span class=\"p\">)])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">flux_ratios</span> <span class=\"o\">=</span> <span class=\"n\">shadow</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">(</span><span class=\"n\">epochs</span><span class=\"p\">,</span> <span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h2 id=\"notes\">Notes</h2>\n\n<ul>\n<li>Currently limited to airless bodies (no atmospheric effects)</li>\n<li>Uses Embree ray-tracing kernel for efficient intersection tests</li>\n<li>Limb darkening coefficients are wavelength-dependent; default values are \nfor optical wavelengths (~500 nm)</li>\n<li>For very close approaches, increase numrays for better accuracy</li>\n<li>Precomputation of SPICE data recommended for large time series</li>\n</ul>\n\n<h2 id=\"references\">References</h2>\n\n<ul>\n<li>Pierce, A.K. &amp; Slaughter, C.D. (1977), \"Solar limb darkening\", \nSolar Physics, 51, 25-41</li>\n<li>Eddington, A.S. (1926), \"The Internal Constitution of the Stars\"</li>\n<li>Neckel, H. &amp; Labs, D. (1994), \"Solar limb darkening 1986-1990\", \nSolar Physics, 153, 91-114</li>\n</ul>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.__init__", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spacecraft</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">body</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bodyRadius</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">numrays</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">sunRadius</span><span class=\"o\">=</span><span class=\"mf\">600000.0</span>,</span><span class=\"param\">\t<span class=\"n\">bodyShape</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bodyFrame</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limbDarkening</span><span class=\"o\">=</span><span class=\"s1\">&#39;Standard&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">precomputation</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.classes.SRP.SunShadow.sunRadius", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.sunRadius", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.spacecraft", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.spacecraft", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.body", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.body", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.limbDarkening", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.limbDarkening", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.pxPlane", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.pxPlane", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.sp_data", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SunShadow.run", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.run", "kind": "function", "doc": "<p>Method to compute eclipse ratio at a single epoch.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epoch: spiceypy epoch</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SunShadow.compute", "modulename": "pyRTX.classes.SRP", "qualname": "SunShadow.compute", "kind": "function", "doc": "<p>Parameters:</p>\n\n<ul>\n<li>epochs: list of epochs</li>\n<li>ncores: number of cores to use for parallel computations</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SolarPressure", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.__init__", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spacecraft</span>,</span><span class=\"param\">\t<span class=\"n\">rayTracer</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">baseflux</span><span class=\"o\">=</span><span class=\"mf\">1361.5</span>,</span><span class=\"param\">\t<span class=\"n\">grouped</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">shadowObj</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lookup</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">precomputation</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.spacecraft", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.spacecraft", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.rayTracer", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.rayTracer", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.baseflux", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.baseflux", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.grouped", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.grouped", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.shadowObj", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.shadowObj", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.lookup", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.lookup", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.sp_data", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.run", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.run", "kind": "function", "doc": "<p>Method to compute solar pressure acceleration at a single epoch.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epoch: spiceypy epoch</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.compute", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.compute", "kind": "function", "doc": "<p>Method to compute the solar pressure acceleration.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epochs: list of epochs</li>\n<li>ncores: number of cores to use for parallel computations</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.lookupCompute", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.lookupCompute", "kind": "function", "doc": "<p>Method to compute the solar pressure force with Look Up Table.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epochs: list of epochs</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epochs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.get_flux", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.get_flux", "kind": "function", "doc": "<p>Method to get the scaled solar flux.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epoch: requested epoch</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.get_force", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.get_force", "kind": "function", "doc": "<p>Compute the SRP force</p>\n\n<p>Parameters:\nflux: Solar input flux [W/m^2]\nA: areas of the mesh faces\ns: incident ray directions\nr: reflcted ray directions\nn: normal unit vector to the faces</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">flux</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_obj</span>,</span><span class=\"param\">\t<span class=\"n\">index_tri</span>,</span><span class=\"param\">\t<span class=\"n\">index_ray</span>,</span><span class=\"param\">\t<span class=\"n\">location</span>,</span><span class=\"param\">\t<span class=\"n\">ray_origins</span>,</span><span class=\"param\">\t<span class=\"n\">ray_directions</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_spacing</span>,</span><span class=\"param\">\t<span class=\"n\">materials</span><span class=\"o\">=</span><span class=\"s1\">&#39;None&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">grouped</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_pack</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.SRP.SolarPressure.srp_core", "modulename": "pyRTX.classes.SRP", "qualname": "SolarPressure.srp_core", "kind": "function", "doc": "<p>Core of SRP computation.\nHighly vectorized version. For explicit algorithm implementation refer to the old version</p>\n\n<p>Parameters:\nflux: solar flux (float, W/m^2)\nindexes_tri: indexes of intersected triangles\nindexes_ray: indexes of intersecting rays\nN: normals\nS: incident direction vectors\nnorm_factor: normalization factor computed from ray spacing (float)\nmesh_obj: trimesh.Trimesh object [Not used for now, will be used when interrogating mesh\n                        for surface properties]</p>\n\n<p>Returns:\nforce: np.array of SRP force</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">flux</span>,</span><span class=\"param\">\t<span class=\"n\">indexes_tri</span>,</span><span class=\"param\">\t<span class=\"n\">indexes_ray</span>,</span><span class=\"param\">\t<span class=\"n\">N</span>,</span><span class=\"param\">\t<span class=\"n\">S</span>,</span><span class=\"param\">\t<span class=\"n\">norm_factor</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_obj</span>,</span><span class=\"param\">\t<span class=\"n\">materials</span><span class=\"o\">=</span><span class=\"s1\">&#39;None&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_pack</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft", "modulename": "pyRTX.classes.Spacecraft", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft", "kind": "class", "doc": "<p>This is the main class for defining spacecraft objects.</p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.__init__", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.__init__", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>name : str \n        Spacecraft name</p>\n\n<p>base_frame : str \n        Spacecraft body (base) frame</p>\n\n<p>spacecraft_model : dict \n        dict of {file:str, frame_type:str, frame_name:str, center:list, specular:float, diffuse:float, UD_rotation:trimesh.rotation}\na dictionary with keys the name of</p>\n\n<pre><code>    file: str \n            the obj file for the part\n\n    frame_type: str \n            'Spice' or 'UD' to choose wether to define a reference to a spice frame or UserDefined one\n            in the case of 'UD' a rotation matrix must be specified in the UD_rotation (optional) key\n\n    frame_name: str \n            The name of the Spice (or UD) frame\n\n    center: list  \n            position of the origin of the object (in km) with respect to the base frame\n\n    specular: float \n            specular coefficient\n\n    diffuse: float \n            diffuse coefficient\n\n    UD_rotation: trimesh.rotation\n            optional specify a user defined rotations matrix\n</code></pre>\n\n<p>units : str \n        units for transformations</p>\n\n<p>mass : float or .nc file\n        Spacecraft mass. Can be a float value or an xarray with times and mass values</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>bla : pyRTX.classes.Spacecraft</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">base_frame</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">spacecraft_model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">units</span><span class=\"o\">=</span><span class=\"s1\">&#39;m&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span>)</span>"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.name", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.part_number", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.part_number", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.base_frame", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.base_frame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.mesh_cont", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.mesh_cont", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.mesh_prop", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.mesh_prop", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.units", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.units", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.conversion_factor", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.conversion_factor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.spacecraft_model", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.spacecraft_model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.material_dict", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.material_dict", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.mass", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.mass", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.sp_data", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.sp_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.add_parts", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.add_parts", "kind": "function", "doc": "<p>Add parts to the model instance</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>spacecraft_model : dict\n        See the main constructor documentation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spacecraft_model</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.subset", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.subset", "kind": "function", "doc": "<p>Return an instance of Spacecraft with only the elements contained\nin the list elem_names.\nSuppose the Spacecraft (self) is composed of elements A,B,C\nSpacecraft.subset(['A','B']) would return a new instance\nof Spacecraft with only the elements A and B</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">elem_names</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.remove_part", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.remove_part", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.pxform_convert", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.pxform_convert", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pxform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.apply_transforms", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.apply_transforms", "kind": "function", "doc": "<p>Method to rotate and translate the components.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>epoch: epoch of the transformation</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.materials", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.materials", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.dump", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.dump", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">split</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.dump_materials", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.dump_materials", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.classes.Spacecraft.Spacecraft.info", "modulename": "pyRTX.classes.Spacecraft", "qualname": "Spacecraft.info", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core", "modulename": "pyRTX.core", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils", "modulename": "pyRTX.core.analysis_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable", "kind": "class", "doc": "<p>This class is used to store results in the shape aof a lookup table.\nThis is mainly used to store the resultas of a set of raytracing results\nexample: the solar pressure for a body is computed for a grid of RA/DEC values.\nthese values can be stored in the LookupTable object and later retrieved.\nThis class offers the possibility of not oly retrieving pre-computed values, but\naslso interpolating between grid points.</p>\n\n<p>NOTE: the grid of the lookup table does not need to be regular\nthe interpolation is based on numpy griddata method which is able to cope\nwith unstructured grids</p>\n\n<p>The main way of retrieving values is through indexing. The following are implemented:</p>\n\n<p>LUT[a,b]: if a, b are in the original lookup table, the original values are returned, otherwise they are interpolated\nLUT[:,:] or LUT[a:b, c:d]: return the original lut sliced as requested\nLUT[:,a]: return the original lut (all elements of first axis, integer-indexed elements of second axis)\nLUT[array-like, array-like]: return the lookup table interpolated in the array-like points</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>linspace_x : np.array(N,)\n        The x axis of the lookup table\nlinspace_y : np.array(M,)\n        The y axis of the lookup table\nvalues : np.ndarray (N,M,1)\n        The lookup table values</p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.__init__", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">linspace_x</span>, </span><span class=\"param\"><span class=\"n\">linspace_y</span>, </span><span class=\"param\"><span class=\"n\">values</span></span>)</span>"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.linspace_x", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.linspace_x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.linspace_y", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.linspace_y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.values", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.values", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.set_interpType", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.set_interpType", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">interpType</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.interp_point", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.interp_point", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTable.quickPlot", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTable.quickPlot", "kind": "function", "doc": "<p>Produce a quick plot of the lookup table</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xlabel : str (Optional)\n        label for the x-axis\nylabel : str (Optional)\n        label for the y-axis\ntitle : str (Optional)\n        title of the plot\nconversion : float (Optional, default 1)\n        a conversion factor for the plotted values. This method will plot X<em>conversion, Y</em>conversion\nclabel : str (Optional)\n        label of the color bar\ncmap : str      (Optional, default 'viridis')\n        the colormap to use (matplotlib colormaps)\nsaveto : str (Optional, default None)\n        if not None: the path to save the plot to (the file extension defines the format)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xlabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ylabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">conversion</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">clabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;viridis&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">saveto</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND", "kind": "class", "doc": "<p>Same concept as the LookupTable class, but allowing for multi-dimensional (&gt;2) tables</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>axes : tuple of np.array\n        The axes of the lookup table\nvalues : np.ndarray(N,M,L,...,1)\ninfo : str\n        A string field to store information about the lookup table. This is set as a class property\n        so it can be requested trhough instance.info\nnp.array : np.array\n        unset</p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.__init__", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">values</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">info</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">np_array</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.axes", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.axes", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.values", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.values", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.info", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.info", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.np_array", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.np_array", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.set_interpType", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.set_interpType", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">interpType</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.get_idx", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.get_idx", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span>, </span><span class=\"param\"><span class=\"n\">search_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.interp_point", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.interp_point", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vals</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.axisExtent", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.axisExtent", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.LookupTableND.quickPlot", "modulename": "pyRTX.core.analysis_utils", "qualname": "LookupTableND.quickPlot", "kind": "function", "doc": "<p>Produce a quick plot of the lookup table</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>xlabel : str (Optional)\n        label for the x-axis\nylabel : str (Optional)\n        label for the y-axis\ntitle : str (Optional)\n        title of the plot\nconversion : float (Optional, default 1)\n        a conversion factor for the plotted values. This method will plot X<em>conversion, Y</em>conversion\nclabel : str (Optional)\n        label of the color bar\ncmap : str      (Optional, default 'viridis')\n        the colormap to use (matplotlib colormaps)\nsaveto : str (Optional, default None)\n        if not None: the path to save the plot to (the file extension defines the format)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">xlabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ylabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">conversion</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">clabel</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;viridis&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">saveto</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.ScatterLookup", "modulename": "pyRTX.core.analysis_utils", "qualname": "ScatterLookup", "kind": "class", "doc": "<p>A class for dealing with zone-scattered lookup tables\nIntended for creating a lookup table of sets of computed values that lie in distinct, DISJUNCT,\nzones of the axes space.\nExample: the value of a variable has been computed in X = [0,1] Y = [0,1] and X = [3,4] Y = [-2,-1]</p>\n\n<p>After instantiating the empty class, the different zones are added. Example</p>\n\n<p>sc = ScatterLookup()\nzone1 = LookupTableND(<em>args, *</em>kwargs)\nzone2 = LookupTableND(<em>args, *</em>kwargs)\nsc.addZone(zone1)\nsc.addZone(zone2)</p>\n\n<p>The value retrieval follows the same rules of indexing as the LookupTable and LookupTableND classes</p>\n"}, {"fullname": "pyRTX.core.analysis_utils.ScatterLookup.zones", "modulename": "pyRTX.core.analysis_utils", "qualname": "ScatterLookup.zones", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.ScatterLookup.zonedef", "modulename": "pyRTX.core.analysis_utils", "qualname": "ScatterLookup.zonedef", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.ScatterLookup.add_zone", "modulename": "pyRTX.core.analysis_utils", "qualname": "ScatterLookup.add_zone", "kind": "function", "doc": "<p>Add a zone</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>ZoneLookup : pyRTX.core.analysis_utils.LookupTableND</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ZoneLookup</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.ScatterLookup.zone_determination", "modulename": "pyRTX.core.analysis_utils", "qualname": "ScatterLookup.zone_determination", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">idxs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.__init__", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">values</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.axes", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.axes", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.values", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.values", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.interpolator", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.interpolator", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vals</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.set_interpType", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.set_interpType", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">interpType</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.get_idx", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.get_idx", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span>, </span><span class=\"param\"><span class=\"n\">search_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.TiffInterpolator.interp_point", "modulename": "pyRTX.core.analysis_utils", "qualname": "TiffInterpolator.interp_point", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vals</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.getSunAngles", "modulename": "pyRTX.core.analysis_utils", "qualname": "getSunAngles", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">scName</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">scFrame</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">correction</span><span class=\"o\">=</span><span class=\"s1\">&#39;LT+S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.epochRange", "modulename": "pyRTX.core.analysis_utils", "qualname": "epochRange", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">startEpoch</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">duration</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.epochRange2", "modulename": "pyRTX.core.analysis_utils", "qualname": "epochRange2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">startEpoch</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">endEpoch</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.computeRADEC", "modulename": "pyRTX.core.analysis_utils", "qualname": "computeRADEC", "kind": "function", "doc": "<p>From a ND array of shape (N, 3), compute RA/DEC</p>\n\n<p>Parameters:\nvecs: [ndarray (N,3)]\nReturns:\nRA, DEC</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vecs</span>, </span><span class=\"param\"><span class=\"n\">periodicity</span><span class=\"o\">=</span><span class=\"mi\">360</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.convertTIFtoMesh", "modulename": "pyRTX.core.analysis_utils", "qualname": "convertTIFtoMesh", "kind": "function", "doc": "<p>Convert a TIF map of emissivities to the format needed for assigning values to each face of a planetary 3D mesh</p>\n\n<p>Parameters:\ntifFile : [str] the path to the TIFF file\nlatSampling: [float, in rad] sampling step of latitude\nlonSampling: [float, in rad] sampling step of longitude\nplanet: [class.Planet] Planet object containing the mesh and the planetary frames\ninferSampling: [bool] wether the importer shall infer the sampling or not\nReturns:\nemissivityInterpolator: [class.LookupTableND] an interpolator for mapping the temperatures on the mesh faces. This is intended to be passed\n                        to the Planet class via the setter method: Planet.emissivity = emissivityInterpolator</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tifFile</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">latSampling</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">inferSampling</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">lonSampling</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">planet</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lat0</span><span class=\"o\">=-</span><span class=\"mf\">1.5707963267948966</span>,</span><span class=\"param\">\t<span class=\"n\">lat1</span><span class=\"o\">=</span><span class=\"mf\">1.5707963267948966</span>,</span><span class=\"param\">\t<span class=\"n\">lon0</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">lon1</span><span class=\"o\">=</span><span class=\"mf\">6.283185307179586</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.convertEpoch", "modulename": "pyRTX.core.analysis_utils", "qualname": "convertEpoch", "kind": "function", "doc": "<p>Convert a Monte epoch string to a spice epoch string</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">monteEpoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.get_spacecraft_area", "modulename": "pyRTX.core.analysis_utils", "qualname": "get_spacecraft_area", "kind": "function", "doc": "<p>Compute a pyRTX.Spacecraft apparent area as seen by the direction specified \nby a pair of right ascension - declination</p>\n\n<p>Input:\nspacecraft [pyRTX.Spacecraft]   : the spacecraft object\nra [float]                                              : right ascension (in rad)\ndec [float]                                     : declination (rad)\nepoch [float or None]                   : epoch for the computation (this is used when moving Spice\n                                                                        frames are used for the Spacecraft definition)</p>\n\n<p>Output:\narea [float]                                    : the apparent area. The measurement units depend on the units of the\n                                                                        Spacecraft object</p>\n\n<p>TODO: avoid hardcoded width/height but rather use an automated method</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">spacecraft</span>, </span><span class=\"param\"><span class=\"n\">ra</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">dec</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.get_sun_exposed_area", "modulename": "pyRTX.core.analysis_utils", "qualname": "get_sun_exposed_area", "kind": "function", "doc": "<p>Compute a pyRTX.Spacecraft apparent area as seen by the direction specified \nby a pair of right ascension - declination</p>\n\n<p>Input:\nspacecraft [pyRTX.Spacecraft]   : the spacecraft object\nra [float]                                              : right ascension (in rad)\ndec [float]                                     : declination (rad)\nepoch [float or None]                   : epoch for the computation (this is used when moving Spice\n                                                                        frames are used for the Spacecraft definition)</p>\n\n<p>Output:\narea [float]                                    : the apparent area. The measurement units depend on the units of the\n                                                                        Spacecraft object</p>\n\n<p>TODO: avoid hardcoded width/height but rather use an automated method</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sc</span>, </span><span class=\"param\"><span class=\"n\">rtx</span>, </span><span class=\"param\"><span class=\"n\">epoch</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.compute_body_positions", "modulename": "pyRTX.core.analysis_utils", "qualname": "compute_body_positions", "kind": "function", "doc": "<p>Functions to compute the relative positions of a target\nbody with respect to an observing body.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>target: target body name</li>\n<li>epochs: list of epochs</li>\n<li>frame: reference frame of output position vector</li>\n<li>obs: observing body name</li>\n<li>abcorr: aberration correction flag.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">frame</span>, </span><span class=\"param\"><span class=\"n\">obs</span>, </span><span class=\"param\"><span class=\"n\">abcorr</span><span class=\"o\">=</span><span class=\"s1\">&#39;LT + S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.analysis_utils.compute_body_states", "modulename": "pyRTX.core.analysis_utils", "qualname": "compute_body_states", "kind": "function", "doc": "<p>Functions to compute the relative position and velocity of a target\nbody with respect to an observing body.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>target: target body name</li>\n<li>epochs: list of epochs</li>\n<li>frame: reference frame of output position vector</li>\n<li>obs: observing body name</li>\n<li>abcorr: aberration correction flag.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"n\">epochs</span>, </span><span class=\"param\"><span class=\"n\">frame</span>, </span><span class=\"param\"><span class=\"n\">obs</span>, </span><span class=\"param\"><span class=\"n\">abcorr</span><span class=\"o\">=</span><span class=\"s1\">&#39;LT + S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.parallel_utils", "modulename": "pyRTX.core.parallel_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.parallel_utils.get_ncores", "modulename": "pyRTX.core.parallel_utils", "qualname": "get_ncores", "kind": "function", "doc": "<p>Returns the number of cores for parallel computations.\nIf not specified, the number of cores is set to the number available on your machine.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lst</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.parallel_utils.is_method", "modulename": "pyRTX.core.parallel_utils", "qualname": "is_method", "kind": "function", "doc": "<p>Checks if the wrapped object is a method of a class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"n\">cls_inst</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.parallel_utils.get_unwrapped", "modulename": "pyRTX.core.parallel_utils", "qualname": "get_unwrapped", "kind": "function", "doc": "<p>Returns the unwrapped version of a class method.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.parallel_utils.parallel", "modulename": "pyRTX.core.parallel_utils", "qualname": "parallel", "kind": "function", "doc": "<p>Decorator for parallel computations.\nThe decorated object can be a class method or a regular function.\nIt applies the function to every item of an iterable performing the computations in parallel. \nThe output will be an iterator which contains the return value of every function call.</p>\n\n<p>The decorated object can accept multiple arguments, but the last positional argument \nmust be an item of the input iterable (e.g. an item of a list / numpy array / range object ...).</p>\n\n<p>If the keyword argument 'n_cores' is specified, the decorated object will run on n_cores processes. \nOtherwise, the number of cores is set to the number available on your machine.</p>\n\n<p>Basic usage:</p>\n\n<ul>\n<li>Define the input iterable:</li>\n</ul>\n\n<p>iterable = [2,5,6,7,3,4,1] </p>\n\n<ul>\n<li>Define the function that will be applied to every item of the input iterable:</li>\n</ul>\n\n<p>@parallel\ndef target_func( some_inputs, item ): \n    ... perform tasks \n    return result</p>\n\n<ul>\n<li>Apply the function to every item of the iterable using 5 cores in parallel:</li>\n</ul>\n\n<p>results = target_func( some_inputs, iterable, n_cores = 5 )   </p>\n\n<p>NOTE: In its definition, the decorated object accepts the item of the iterable as last positional argument.\nHowever, in the function call, you must pass directly the iterable (the list of integers in this example) \nin place of the item. Every other positional argument before the iterable must be the same.\nIn the function call it is possible to also pass the number of cores, but only as a keyword argument.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.physical_utils", "modulename": "pyRTX.core.physical_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.physical_utils.preprocess_RTX_geometry", "modulename": "pyRTX.core.physical_utils", "qualname": "preprocess_RTX_geometry", "kind": "function", "doc": "<p>Preprocess the RTX output to obtain the information required</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mesh_obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.physical_utils.preprocess_materials", "modulename": "pyRTX.core.physical_utils", "qualname": "preprocess_materials", "kind": "function", "doc": "<p>Get the material properties and set up an array for handling\nParameters:\nmaterial_dict: a dictionary with the shape:\n        {'props': dictionary of properties for each material, 'idxs': indexes of faces associated with each material}</p>\n\n<p>Returns:\nprop_container: a (len(mesh), 2) numpy array containing [specular, diffuse] coefficients for each face of the mesh</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">material_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.physical_utils.srp_core", "modulename": "pyRTX.core.physical_utils", "qualname": "srp_core", "kind": "function", "doc": "<p>Core of SRP computation.\nHighly vectorized version. For explicit algorithm implementation refer to the old version</p>\n\n<p>Parameters:\nflux: solar flux (float, W/m^2)\nindexes_tri: indexes of intersected triangles\nindexes_ray: indexes of intersecting rays\nN: normals\nS: incident direction vectors\nnorm_factor: normalization factor computed from ray spacing (float)\nmesh_obj: trimesh.Trimesh object [Not used for now, will be used when interrogating mesh\n                        for surface properties]</p>\n\n<p>Returns:\nforce: np.array of SRP force</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">flux</span>,</span><span class=\"param\">\t<span class=\"n\">indexes_tri</span>,</span><span class=\"param\">\t<span class=\"n\">indexes_ray</span>,</span><span class=\"param\">\t<span class=\"n\">N</span>,</span><span class=\"param\">\t<span class=\"n\">S</span>,</span><span class=\"param\">\t<span class=\"n\">norm_factor</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_obj</span>,</span><span class=\"param\">\t<span class=\"n\">materials</span><span class=\"o\">=</span><span class=\"s1\">&#39;None&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_pack</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.physical_utils.compute_srp", "modulename": "pyRTX.core.physical_utils", "qualname": "compute_srp", "kind": "function", "doc": "<p>Compute the SRP force</p>\n\n<p>Parameters:\nflux: Solar input flux [W/m^2]\nA: areas of the mesh faces\ns: incident ray directions\nr: reflcted ray directions\nn: normal unit vector to the faces</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">flux</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_obj</span>,</span><span class=\"param\">\t<span class=\"n\">index_tri</span>,</span><span class=\"param\">\t<span class=\"n\">index_ray</span>,</span><span class=\"param\">\t<span class=\"n\">location</span>,</span><span class=\"param\">\t<span class=\"n\">ray_origins</span>,</span><span class=\"param\">\t<span class=\"n\">ray_directions</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_spacing</span>,</span><span class=\"param\">\t<span class=\"n\">materials</span><span class=\"o\">=</span><span class=\"s1\">&#39;None&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">grouped</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_pack</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.shadow_utils", "modulename": "pyRTX.core.shadow_utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.shadow_utils.circular_mask", "modulename": "pyRTX.core.shadow_utils", "qualname": "circular_mask", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">R</span>, </span><span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">origin</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.shadow_utils.circular_rim", "modulename": "pyRTX.core.shadow_utils", "qualname": "circular_rim", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">R</span>, </span><span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">origin</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.shadow_utils.compute_directions", "modulename": "pyRTX.core.shadow_utils", "qualname": "compute_directions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pixelCoords</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.shadow_utils.compute_beta", "modulename": "pyRTX.core.shadow_utils", "qualname": "compute_beta", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">origin</span>, </span><span class=\"param\"><span class=\"n\">R</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.shadow_utils.compute_pixel_intensities", "modulename": "pyRTX.core.shadow_utils", "qualname": "compute_pixel_intensities", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">beta</span>, </span><span class=\"param\"><span class=\"n\">Type</span><span class=\"o\">=</span><span class=\"s1\">&#39;Standard&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt", "modulename": "pyRTX.core.utils_rt", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.parallelize", "modulename": "pyRTX.core.utils_rt", "qualname": "parallelize", "kind": "function", "doc": "<p>Define a general parallelization framework to speedup computations\n Parameters</p>\n\n<hr />\n\n<p>iterator : array_like\n     the array-like object over which to parallelize\n function : function handle\n     the function that must be called by each subprocess. The function should be of the form y = f(iterator)\n chunks : int\n     number of parallel workers</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : array_like\n     the result of the parallelized computation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iterator</span>, </span><span class=\"param\"><span class=\"n\">function</span>, </span><span class=\"param\"><span class=\"n\">chunks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.chunker", "modulename": "pyRTX.core.utils_rt", "qualname": "chunker", "kind": "function", "doc": "<p>Divide an iterator or array into approximately equal-sized chunks for\nparallel processing.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>iterator : array_like\n    The array-like object to divide into chunks.\nchunks : int\n    Number of chunks to create.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : list of arrays\n    List containing the chunked arrays. Chunks will be approximately equal\n    in size, with the last chunk potentially being smaller.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Uses numpy.array_split which handles uneven divisions automatically.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">iterator</span>, </span><span class=\"param\"><span class=\"n\">chunks</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.pxform_convert", "modulename": "pyRTX.core.utils_rt", "qualname": "pxform_convert", "kind": "function", "doc": "<p>Convert a SPICE-generated rotation matrix (pxform) to the 4x4 homogeneous\ntransformation matrix format required by trimesh.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pxform : array_like, shape (3, 3)\n    The 3x3 rotation matrix from SPICE (obtained via spiceypy.pxform).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : ndarray, shape (4, 4)\n    The 4x4 homogeneous transformation matrix with the rotation in the\n    upper-left 3x3 block, zeros in the translation column, and [0,0,0,0]\n    in the bottom row.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Trimesh uses 4x4 homogeneous transformation matrices for geometric operations.\nThis function adds the necessary padding to convert a pure rotation matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pxform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.block_normalize", "modulename": "pyRTX.core.utils_rt", "qualname": "block_normalize", "kind": "function", "doc": "<p>Compute unit vectors for a block of vectors efficiently using vectorized\noperations.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : ndarray, shape (N, 3) or (3,)\n    Array of vectors to normalize. Can be a single vector or multiple vectors.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : ndarray, same shape as V\n    The normalized vectors (unit vectors with magnitude 1).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Uses vectorized numpy operations for efficiency with large arrays. Handles\nboth single vectors and arrays of vectors automatically.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.block_dot", "modulename": "pyRTX.core.utils_rt", "qualname": "block_dot", "kind": "function", "doc": "<p>Perform element-wise dot product between corresponding vectors in two arrays.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>a : ndarray, shape (N, m)\n    First array of vectors.\nb : ndarray, shape (N, m)\n    Second array of vectors (must have same shape as a).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : ndarray, shape (N,)\n    Array containing the dot product of each pair of corresponding vectors.\n    result[i] = a[i] \u00b7 b[i]</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is more efficient than using a loop for computing many dot products.\nEquivalent to np.einsum('ij,ij->i', a, b) but more readable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.pixel_plane", "modulename": "pyRTX.core.utils_rt", "qualname": "pixel_plane", "kind": "function", "doc": "<p>Generate a rectangular pixel array (grid of rays) for ray tracing, as defined\nin Li et al., 2018. This is the explicit implementation showing the full\nalgorithm.</p>\n\n<p>This function creates a planar grid of ray origins and directions pointing\ntoward a specified direction in 3D space, useful for simulating parallel\nlight sources like the Sun.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>d0 : float\n    Distance of the pixel plane from the origin (in meters). This defines\n    how far the ray origins are from the coordinate system origin.\nlon : float\n    Longitude of the pixel plane's center direction (in radians). Defines\n    the azimuthal angle in spherical coordinates.\nlat : float\n    Latitude of the pixel plane's center direction (in radians). Defines\n    the elevation angle in spherical coordinates.\nwidth : float, default=1\n    Width of the plane (in meters). The plane extends \u00b1width/2 in the\n    horizontal direction.\nheight : float, default=1\n    Height of the plane (in meters). The plane extends \u00b1height/2 in the\n    vertical direction.\nray_spacing : float, default=0.1\n    Spacing between adjacent rays (in meters). Smaller values create denser\n    ray grids but increase computation time.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>locs : ndarray, shape (N, 3)\n    Ray origin positions in 3D space. N = (width/ray_spacing + 1) \u00d7 \n    (height/ray_spacing + 1).\ndirs : ndarray, shape (N, 3)\n    Ray direction unit vectors. All rays point toward the origin (or away\n    from the direction specified by lon/lat).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The pixel plane is oriented perpendicular to the direction vector defined\nby (lon, lat) and positioned at distance d0 from the origin. This creates\na uniform grid of parallel rays suitable for simulating distant light sources.</p>\n\n<p>For performance-critical applications, use pixel_plane_opt instead.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p>Li et al., 2018 - Solar radiation pressure modeling methodology</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d0</span>, </span><span class=\"param\"><span class=\"n\">lon</span>, </span><span class=\"param\"><span class=\"n\">lat</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">ray_spacing</span><span class=\"o\">=</span><span class=\"mf\">0.1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.fast_vector_build", "modulename": "pyRTX.core.utils_rt", "qualname": "fast_vector_build", "kind": "function", "doc": "<p>Efficiently build a pixel array coordinate grid using Numba's JIT compilation\nfor performance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>linsp1 : ndarray, shape (dim1,)\n    Linear space defining positions along the first dimension (typically width).\nlinsp2 : ndarray, shape (dim2,)\n    Linear space defining positions along the second dimension (typically height).\ndim1 : int\n    Number of points in the first dimension.\ndim2 : int\n    Number of points in the second dimension.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>result : ndarray, shape (dim1 \u00d7 dim2, 3)\n    Array of 3D coordinates forming a rectangular grid in the y-z plane\n    (x=0 for all points). The grid is built by nested iteration over linsp1\n    and linsp2.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is JIT-compiled with Numba for significant performance improvement\nover pure Python loops. Used internally by pixel_plane_opt.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">linsp1</span>, </span><span class=\"param\"><span class=\"n\">linsp2</span>, </span><span class=\"param\"><span class=\"n\">dim1</span>, </span><span class=\"param\"><span class=\"n\">dim2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.pixel_plane_opt", "modulename": "pyRTX.core.utils_rt", "qualname": "pixel_plane_opt", "kind": "function", "doc": "<p>Generate a rectangular pixel array for ray tracing - optimized version with\noptional ray packet subdivision.</p>\n\n<p>This is a performance-optimized implementation of pixel_plane that uses\nvectorized operations and Numba JIT compilation. It also supports dividing\nthe rays into packets to avoid segmentation faults with very large ray counts.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>d0 : float\n    Distance of the pixel plane from the origin (in meters).\nlon : float\n    Longitude of the pixel plane's center direction (in radians).\nlat : float\n    Latitude of the pixel plane's center direction (in radians).\nwidth : float, default=1\n    Width of the plane (in meters).\nheight : float, default=1\n    Height of the plane (in meters).\nray_spacing : float, default=0.1\n    Spacing between adjacent rays (in meters). Determines ray grid density.\npackets : int, default=1\n    Number of ray packets to subdivide the rays into. Use values &gt; 1 to\n    avoid segmentation faults or memory issues with very large numbers of\n    rays (typically &gt; 10^6). Each packet is processed separately by the\n    ray tracer.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>locs : ndarray or list of ndarrays\n    Ray origin positions. If packets=1, returns single array of shape (N, 3).\n    If packets>1, returns list of arrays, each containing a subset of rays.\ndirs : ndarray or list of ndarrays\n    Ray direction unit vectors. Same structure as locs.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This is the recommended function for pixel plane generation due to its\nperformance optimizations. Use packets &gt; 1 when dealing with very dense\nray grids (small ray_spacing values).</p>\n\n<p>The function uses Numba JIT compilation via fast_vector_build for efficient\ncoordinate grid generation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d0</span>, </span><span class=\"param\"><span class=\"n\">lon</span>, </span><span class=\"param\"><span class=\"n\">lat</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">ray_spacing</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>, </span><span class=\"param\"><span class=\"n\">packets</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.reflected", "modulename": "pyRTX.core.utils_rt", "qualname": "reflected", "kind": "function", "doc": "<p>Compute reflected ray directions given incoming rays and surface normals.\nUses the law of reflection: r = i - 2(i\u00b7n)n</p>\n\n<p>This is a vectorized implementation using numpy.einsum for efficient\ncomputation of many reflections simultaneously.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>incoming : ndarray, shape (N, 3)\n    Incoming ray direction vectors (do not need to be normalized).\nnormal : ndarray, shape (N, 3)\n    Surface normal vectors at reflection points (should be unit vectors).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>reflected : ndarray, shape (N, 3)\n    Reflected ray direction vectors. These are NOT normalized - maintain\n    the same magnitude as the incoming vectors.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The reflection formula used is: r = i - 2(i\u00b7n)n, where:</p>\n\n<ul>\n<li>i is the incoming direction</li>\n<li>n is the surface normal</li>\n<li>r is the reflected direction</li>\n</ul>\n\n<p>This formula gives the specular (mirror-like) reflection direction.\nUses np.einsum for efficient vectorized dot product computation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">incoming</span>, </span><span class=\"param\"><span class=\"n\">normal</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.get_orthogonal", "modulename": "pyRTX.core.utils_rt", "qualname": "get_orthogonal", "kind": "function", "doc": "<p>Generate a unit vector orthogonal to the input vector using randomization.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>v : ndarray, shape (3,)\n    Input vector to which the result should be orthogonal.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>x : ndarray, shape (3,)\n    Unit vector orthogonal to v (x \u00b7 v = 0 and ||x|| = 1).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Uses a random vector projection method: generates a random 3D vector,\nprojects out the component parallel to v, and normalizes. This is used\ninternally for constructing local coordinate systems on surface normals.</p>\n\n<p>JIT-compiled with Numba for performance.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">v</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.sample_lambert_dist", "modulename": "pyRTX.core.utils_rt", "qualname": "sample_lambert_dist", "kind": "function", "doc": "<p>Generate a cloud of direction vectors following the Lambert cosine\ndistribution (also known as Lambertian distribution or cosine-weighted\nhemisphere sampling).</p>\n\n<p>The Lambert distribution models ideal diffuse reflection where the\nprobability of a ray being reflected in a given direction is proportional\nto the cosine of the angle between that direction and the surface normal.\nThis is physically accurate for perfectly diffuse (Lambertian) surfaces.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>normal : ndarray, shape (3,)\n    Surface normal vector defining the hemisphere orientation (should be\n    a unit vector).\nnum : int, default=100\n    Number of sample directions to generate.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>v : ndarray, shape (num, 3)\n    Array of sampled direction vectors distributed according to Lambert's\n    cosine law. All vectors point into the hemisphere defined by the normal.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The sampling uses spherical coordinates with:</p>\n\n<ul>\n<li>\u03b8 (polar angle): sampled as \u03b8 = arccos(\u221a\u03be) where \u03be ~ U(0,1)</li>\n<li>\u03c8 (azimuthal angle): sampled uniformly as \u03c8 ~ U(0, 2\u03c0)</li>\n</ul>\n\n<p>This ensures that the probability density is proportional to cos(\u03b8), which\nis characteristic of ideal diffuse reflection (Lambert's cosine law).</p>\n\n<p>JIT-compiled with Numba for performance. Used for modeling diffuse\nreflection in ray tracing.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p>Lambert's Cosine Law: I = I\u2080 cos(\u03b8) where \u03b8 is the angle from the normal</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">normal</span>, </span><span class=\"param\"><span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.diffuse", "modulename": "pyRTX.core.utils_rt", "qualname": "diffuse", "kind": "function", "doc": "<p>Compute multiple diffuse reflection directions for an array of surface\nnormals by sampling the Lambert cosine distribution.</p>\n\n<p>For each input normal, generates num diffusely reflected ray directions\nfollowing Lambert's cosine law. This models realistic diffuse scattering\nfrom rough surfaces.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>normals : ndarray, shape (N, 3)\n    Array of surface normal unit vectors at reflection points.\nnum : int, default=10\n    Number of diffuse samples to generate for each normal. Higher values\n    give more accurate diffuse reflection modeling but increase computation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>diffuse_directions : ndarray, shape (N \u00d7 num, 3)\n    Array of sampled diffuse direction vectors. For each of the N input\n    normals, generates num directions, resulting in N\u00d7num total directions.\n    Directions are ordered so that directions [i\u00d7num : (i+1)\u00d7num] correspond\n    to normal i.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is used to model non-specular (rough) surface reflections.\nEach diffuse direction is randomly sampled from the hemisphere above the\nsurface, weighted by the cosine of the angle from the normal (Lambert's law).</p>\n\n<p>The returned array can be fed directly into the ray tracer to simulate\nsecondary illumination from diffuse reflections.</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">normals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>  <span class=\"c1\"># Two normals</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dirs</span> <span class=\"o\">=</span> <span class=\"n\">diffuse</span><span class=\"p\">(</span><span class=\"n\">normals</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>  <span class=\"c1\"># 5 samples each</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dirs</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">(10, 3)  # 2 normals \u00d7 5 samples = 10 directions</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">normals</span>, </span><span class=\"param\"><span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.compute_secondary_bounce", "modulename": "pyRTX.core.utils_rt", "qualname": "compute_secondary_bounce", "kind": "function", "doc": "<p>Prepare ray origins and directions for subsequent ray tracing bounces by\ncomputing specular and optionally diffuse reflection directions.</p>\n\n<p>This function takes the results of a ray-surface intersection and computes\nthe reflected rays needed for the next bounce iteration in multi-bounce\nray tracing.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>location : ndarray, shape (N_hits, 3)\n    3D coordinates of ray-surface intersection points.\nindex_tri : ndarray, shape (N_hits,)\n    Indices of the mesh faces (triangles) that were intersected by rays.\nmesh_obj : trimesh.Trimesh\n    The mesh object containing geometry information (vertices, faces, normals).\nray_directions : ndarray, shape (N_rays, 3)\n    Direction vectors of the incident rays (before intersection).\nindex_ray : ndarray, shape (N_hits,)\n    Indices of the rays that successfully intersected the mesh. Used to\n    map from the original ray array to the subset that hit surfaces.\ndiffusion : bool, default=False\n    If True, compute diffuse reflection directions in addition to specular\n    reflections. Used for modeling rough surface scattering.\nnum_diffuse : int or None, default=None\n    Number of diffuse samples per intersection point. Required if\n    diffusion=True, ignored otherwise.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>location : ndarray, shape (N_hits, 3)\n    Same as input location (pass-through for convenience).\nreflect_dirs : ndarray, shape (N_hits, 3)\n    Specularly reflected ray directions for each intersection point.\n    Computed using the law of reflection with surface normals.\ndiffuse_dirs : ndarray, shape (N_hits \u00d7 num_diffuse, 3) or int\n    If diffusion=True: array of diffusely reflected directions sampled\n    from Lambert distribution for each intersection point.\n    If diffusion=False: returns -1 (dummy value for consistent return signature).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function is typically called iteratively in multi-bounce ray tracing:</p>\n\n<ol>\n<li>First bounce: rays from source hit surface</li>\n<li>Compute secondary bounces from intersection points</li>\n<li>Trace secondary rays</li>\n<li>Repeat for N bounces</li>\n</ol>\n\n<p>The specular reflections follow the law of reflection, while diffuse\nreflections sample the Lambert cosine distribution, providing physically\naccurate modeling of both mirror-like and rough surfaces.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">location</span>,</span><span class=\"param\">\t<span class=\"n\">index_tri</span>,</span><span class=\"param\">\t<span class=\"n\">mesh_obj</span>,</span><span class=\"param\">\t<span class=\"n\">ray_directions</span>,</span><span class=\"param\">\t<span class=\"n\">index_ray</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.save_for_visualization", "modulename": "pyRTX.core.utils_rt", "qualname": "save_for_visualization", "kind": "function", "doc": "<p>Save ray tracing results to a pickled dictionary for post-processing and\nvisualization.</p>\n\n<p>Creates a standardized output format that can be loaded by visualization\nscripts (see visual_utils module) for analyzing ray tracing results,\ncreating visualizations, and debugging ray path geometries.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>outputFilePath : str\n    Path to output file. Should end with '.pkl' extension. Parent directory\n    must exist.\nmesh : trimesh.Trimesh\n    The mesh object that was ray-traced. Contains geometry (vertices, faces,\n    normals) for visualization.\nray_origins : list of ndarrays\n    List containing ray origin arrays for each bounce. Each element is an\n    array of shape (N_rays_i, 3) where i is the bounce number.\nray_directions : list of ndarrays\n    List containing ray direction arrays for each bounce. Same structure\n    as ray_origins.\nlocation : list of ndarrays\n    List containing intersection point coordinates for each bounce. Each\n    element is shape (N_hits_i, 3).\nindex_tri : list of ndarrays\n    List containing indices of intersected triangles for each bounce.\n    Each element is shape (N_hits_i,).\ndiffusion_pack : list or None\n    Diffuse ray tracing data if computed, otherwise None. Contains:\n    [index_tri_diffusion, index_ray_diffusion, ray_directions_diffusion,\n     location_diffusion] for visualization of diffuse scattering.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None\n    Data is written to file at outputFilePath.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The output file contains a dictionary with keys:</p>\n\n<ul>\n<li>'mesh': trimesh.Trimesh object</li>\n<li>'ray_origins': list of origin arrays per bounce</li>\n<li>'ray_directions': list of direction arrays per bounce  </li>\n<li>'locations': list of intersection point arrays per bounce</li>\n<li>'index_tri': list of triangle index arrays per bounce</li>\n<li>'diffusion_pack': diffuse ray data or None</li>\n</ul>\n\n<p>This standardized format allows visualization scripts to recreate the full\nray tracing geometry including multiple bounces and diffuse scattering.</p>\n\n<p>The file is saved using pickle protocol 4 for Python 3 compatibility.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">outputFilePath</span>,</span><span class=\"param\">\t<span class=\"n\">mesh</span>,</span><span class=\"param\">\t<span class=\"n\">ray_origins</span>,</span><span class=\"param\">\t<span class=\"n\">ray_directions</span>,</span><span class=\"param\">\t<span class=\"n\">location</span>,</span><span class=\"param\">\t<span class=\"n\">index_tri</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion_pack</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.exportEXAC", "modulename": "pyRTX.core.utils_rt", "qualname": "exportEXAC", "kind": "function", "doc": "<p>Export acceleration data to GEODYN EXAC (External Accelerations) file format.</p>\n\n<p>GEODYN is NASA's precision orbit determination software. The EXAC format is\na Fortran-formatted binary file used to provide time-varying external\naccelerations (such as solar radiation pressure) to the orbit propagator.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>satelliteID : int\n    Satellite identifier code used in GEODYN processing.\ndata : ndarray, shape (N, 3)\n    Acceleration data to be written, in km/s\u00b2. Each row is [ax, ay, az]\n    at one time step.\ntstep : int or float\n    Time step between data records in seconds (e.g., 60 for 1-minute data).\nstartTime : datetime.datetime\n    Start time of the data series. Must include date and time information\n    down to microseconds.\nendTime : datetime.datetime\n    End time of the data series. Must be consistent with len(data) and tstep.\noutFileName : str\n    Path to output EXAC file. Typically uses .exac or .bin extension.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None\n    Data is written to binary file at outFileName.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>EXAC File Structure:</p>\n\n<ul>\n<li>Master header record: Control parameters and file type identifier</li>\n<li>Satellite-specific header: Satellite ID, time step, start/end times</li>\n<li>Data records: Time stamp + 3D acceleration vector + padding zeros</li>\n</ul>\n\n<p>Time Format:</p>\n\n<ul>\n<li>Stored as YYMMDDHHMMSS\u03bc\u03bc\u03bc\u03bc\u03bc\u03bc (year-month-day-hour-minute-second-microsecond)</li>\n<li>Year uses 2-digit format (YY)</li>\n</ul>\n\n<p>Coordinate System:</p>\n\n<ul>\n<li>Accelerations should be in the same reference frame as the GEODYN\norbit integration (typically J2000 or ICRF)</li>\n</ul>\n\n<p>Units:</p>\n\n<ul>\n<li>Accelerations: km/s\u00b2</li>\n<li>Time step: seconds</li>\n</ul>\n\n<p>This format is used for high-precision orbit determination where external\nnon-gravitational forces (solar pressure, atmospheric drag, etc.) need to\nbe accurately modeled.</p>\n\n<p>Requires scipy.io.FortranFile for binary I/O operations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">satelliteID</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">tstep</span>, </span><span class=\"param\"><span class=\"n\">startTime</span>, </span><span class=\"param\"><span class=\"n\">endTime</span>, </span><span class=\"param\"><span class=\"n\">outFileName</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.Embree3_init_geometry", "modulename": "pyRTX.core.utils_rt", "qualname": "Embree3_init_geometry", "kind": "function", "doc": "<p>Initialize mesh geometry for ray tracing using the Embree 3 ray tracing kernel.</p>\n\n<p>Converts a trimesh mesh object into an EmbreeTrimeshShapeModel that can be\nefficiently ray-traced using Intel's Embree library. Precomputes surface\nnormals and face areas for performance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mesh_obj : trimesh.Trimesh\n    Input mesh object containing vertices and faces. Must be a valid\n    triangular mesh.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>scene : EmbreeTrimeshShapeModel\n    Shape model object containing:\n    - V: vertex coordinates array\n    - F: face index array\n    - N: face normal vectors\n    - A: face areas\n    - scene: Embree scene object for ray tracing</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function performs initial geometry setup required by Embree:</p>\n\n<ol>\n<li>Extracts vertices (V) and faces (F) from mesh</li>\n<li>Computes face normals (N) and areas (A)</li>\n<li>Creates Embree device, geometry, and scene objects</li>\n<li>Loads vertex and index buffers into Embree</li>\n</ol>\n\n<p>The returned object can be used with Embree's ray intersection functions\nfor high-performance ray tracing. Embree uses hardware-accelerated BVH\n(Bounding Volume Hierarchy) structures for fast ray-triangle intersections.</p>\n\n<p>NOTE: The Embree 3 wrapper functions were developed by Sam Potter\n(<a href=\"https://github.com/sampotter/python-embree\">https://github.com/sampotter/python-embree</a>)</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>EmbreeTrimeshShapeModel : The shape model class\nRTXkernel : Main ray tracing interface</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mesh_obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.Embree3_init_rayhit", "modulename": "pyRTX.core.utils_rt", "qualname": "Embree3_init_rayhit", "kind": "function", "doc": "<p>Initialize Embree 3 RayHit data structure for ray tracing queries.</p>\n\n<p>Creates and configures an Embree RayHit1M object that stores ray information\n(origins, directions, parameters) and will be populated with hit information\n(intersection distances, geometry IDs) by the ray tracer.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>ray_origins : ndarray, shape (N, 3)\n    Starting positions of rays in 3D space.\nray_directions : ndarray, shape (N, 3)\n    Direction vectors of rays (do not need to be normalized; Embree handles\n    this internally).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>rayhit : embree.RayHit1M\n    Initialized RayHit structure containing:\n    - org: ray origin coordinates (set from ray_origins)\n    - dir: ray direction vectors (set from ray_directions)\n    - tnear: minimum ray parameter (set to 0.0 to trace from origin)\n    - tfar: maximum ray parameter (set to infinity for unbounded rays)\n    - prim_id: primitive (triangle) ID (initialized to INVALID, filled by tracer)\n    - geom_id: geometry ID (initialized to INVALID, filled by tracer)</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The RayHit1M structure supports tracing multiple rays simultaneously (the \"1M\"\nindicates \"1 Million\" rays capability). After calling Embree's intersect\nfunction, the structure will contain:</p>\n\n<ul>\n<li>Updated tnear/tfar values indicating intersection distances</li>\n<li>prim_id: index of intersected triangle (-1 if no hit)</li>\n<li>geom_id: geometry identifier (-1 if no hit)</li>\n<li>uv: barycentric coordinates of intersection point within triangle</li>\n</ul>\n\n<p>The tnear parameter is set to 0.0 rather than a small epsilon to avoid\nmissing intersections, but this may cause numerical issues with very close\nsurfaces. Adjust if needed for specific applications.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ray_origins</span>, </span><span class=\"param\"><span class=\"n\">ray_directions</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.Embree3_dump_solution", "modulename": "pyRTX.core.utils_rt", "qualname": "Embree3_dump_solution", "kind": "function", "doc": "<p>Extract and process ray-surface intersection results from Embree RayHit structure.</p>\n\n<p>After Embree's ray tracing kernel completes, this function extracts the\nintersection data and converts it into standard numpy arrays. It computes\nactual 3D intersection point coordinates from barycentric coordinates.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>rayhit : embree.RayHit1M\n    RayHit structure populated by Embree's intersect function, containing\n    primitive IDs, geometry IDs, barycentric coordinates, etc.\nV : ndarray, shape (N_vertices, 3)\n    Vertex coordinates of the mesh.\nF : ndarray, shape (N_faces, 3)\n    Face indices of the mesh (each row contains indices of 3 vertices\n    forming a triangle).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>hits : ndarray, shape (N_hits,) or int\n    Indices of triangles that were intersected. Returns -1 if no hits.\nnhits : int\n    Number of rays that intersected the mesh. Returns -1 if no hits.\nidh : ndarray, shape (N_hits,) or int\n    Indices of rays that successfully hit the mesh (mapping from original\n    ray array to hit subset). Returns -1 if no hits.\nPh : ndarray, shape (N_hits, 3) or int\n    3D coordinates of intersection points computed from barycentric\n    coordinates. Returns -1 if no hits.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The function identifies valid hits by checking if prim_id != INVALID_GEOMETRY_ID.</p>\n\n<p>For valid hits, intersection points are computed using barycentric interpolation:\n    Ph = v1 + (v2 - v1) * u + (v3 - v1) * v\nwhere:</p>\n\n<ul>\n<li>v1, v2, v3 are the triangle vertices</li>\n<li>u, v are barycentric coordinates from rayhit.uv</li>\n<li>Ph is the 3D intersection point</li>\n</ul>\n\n<p>If no intersections occurred (nhits=0), all return values are -1 to indicate\nno valid data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rayhit</span>, </span><span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.cgal_init_geometry", "modulename": "pyRTX.core.utils_rt", "qualname": "cgal_init_geometry", "kind": "function", "doc": "<p>Initialize mesh geometry for ray tracing using the CGAL (Computational Geometry\nAlgorithms Library) ray tracing kernel.</p>\n\n<p>Converts a trimesh mesh object into a CgalTrimeshShapeModel that uses CGAL's\nAABB (Axis-Aligned Bounding Box) tree for efficient ray-triangle intersections.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mesh_obj : trimesh.Trimesh\n    Input mesh object containing vertices and faces.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>CgalTrimeshShapeModel : shape model object\n    Shape model configured for CGAL ray tracing, containing:\n    - V: vertex coordinates\n    - F: face indices\n    - N: face normals\n    - A: face areas\n    - aabb: CGAL AABB tree structure for fast queries</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>CGAL is a C++ library providing robust geometric algorithms. The AABB tree\nstructure enables efficient ray tracing through hierarchical spatial subdivision.</p>\n\n<p>This function is adapted from python-flux. CGAL may be more robust than\nEmbree for certain edge cases (nearly degenerate triangles, numerical precision\nissues) but is typically slower for large numbers of rays.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>CgalTrimeshShapeModel : The CGAL-based shape model class\nRTXkernel : Main ray tracing interface that can use CGAL kernel</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mesh_obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.get_centroids", "modulename": "pyRTX.core.utils_rt", "qualname": "get_centroids", "kind": "function", "doc": "<p>Compute the geometric centroids of all triangular faces in a mesh.</p>\n\n<p>The centroid of a triangle is the arithmetic mean of its three vertices,\nrepresenting the triangle's center of mass (assuming uniform density).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : ndarray, shape (N_vertices, 3)\n    Vertex coordinates of the mesh.\nF : ndarray, shape (N_faces, 3)\n    Face indices. Each row contains three vertex indices forming a triangle.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>P : ndarray, shape (N_faces, 3)\n    Centroid coordinates for each face. P[i] = (V[F[i][0]] + V[F[i][1]] +\n    V[F[i][2]]) / 3</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Uses vectorized numpy operations: V[F] creates shape (N_faces, 3, 3) array\nwhere V[F][i] is the 3\u00d73 matrix of vertices for face i. Taking mean along\naxis=1 computes centroids efficiently for all faces simultaneously.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.get_cross_products", "modulename": "pyRTX.core.utils_rt", "qualname": "get_cross_products", "kind": "function", "doc": "<p>Compute cross products of edge vectors for all triangular faces in a mesh.</p>\n\n<p>For each triangle, computes the cross product of two edge vectors. The\nmagnitude of this cross product equals twice the triangle's area, and its\ndirection is perpendicular to the triangle plane (unnormalized normal).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : ndarray, shape (N_vertices, 3)\n    Vertex coordinates of the mesh.\nF : ndarray, shape (N_faces, 3)\n    Face indices. Each row contains three vertex indices [v0, v1, v2].</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>C : ndarray, shape (N_faces, 3)\n    Cross product vectors for each face. C[i] = (v1 - v0) \u00d7 (v2 - v0)\n    where v0, v1, v2 are the vertices of triangle i.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Used internally by get_face_areas and get_surface_normals for efficient\nvectorized computation of geometric properties.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.get_face_areas", "modulename": "pyRTX.core.utils_rt", "qualname": "get_face_areas", "kind": "function", "doc": "<p>Compute the areas of all triangular faces in a mesh.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : ndarray, shape (N_vertices, 3)\n    Vertex coordinates of the mesh.\nF : ndarray, shape (N_faces, 3)\n    Face indices.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>A : ndarray, shape (N_faces,)\n    Area of each face in the same units as V (e.g., if V is in meters,\n    areas are in square meters).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.get_surface_normals", "modulename": "pyRTX.core.utils_rt", "qualname": "get_surface_normals", "kind": "function", "doc": "<p>Compute outward-pointing unit normal vectors for all triangular faces.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : ndarray, shape (N_vertices, 3)\n    Vertex coordinates of the mesh.\nF : ndarray, shape (N_faces, 3)\n    Face indices.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>N : ndarray, shape (N_faces, 3)\n    Unit normal vectors perpendicular to each face. Direction follows\n    right-hand rule with respect to vertex ordering in F.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.get_surface_normals_and_face_areas", "modulename": "pyRTX.core.utils_rt", "qualname": "get_surface_normals_and_face_areas", "kind": "function", "doc": "<p>Efficiently compute both surface normals and face areas simultaneously.</p>\n\n<p>This is more efficient than calling get_surface_normals and get_face_areas\nseparately because it computes the cross products only once.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : ndarray, shape (N_vertices, 3)\n    Vertex coordinates of the mesh.\nF : ndarray, shape (N_faces, 3)\n    Face indices.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>N : ndarray, shape (N_faces, 3)\n    Unit normal vectors for each face.\nA : ndarray, shape (N_faces,)\n    Area of each face.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Computation steps:</p>\n\n<ol>\n<li>Compute cross products C = (v1 - v0) \u00d7 (v2 - v0)</li>\n<li>Compute magnitudes ||C||</li>\n<li>Normals: N = C / ||C||</li>\n<li>Areas: A = ||C|| / 2</li>\n</ol>\n\n<p>This is the recommended function when both quantities are needed, as it\navoids redundant cross product calculations.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.ShapeModel", "modulename": "pyRTX.core.utils_rt", "qualname": "ShapeModel", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel", "kind": "class", "doc": "<p>A shape model consisting of a single triangle mesh.</p>\n", "bases": "ShapeModel"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.__init__", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.__init__", "kind": "function", "doc": "<p>Initialize a triangle mesh shape model. No assumption is made about\nthe way vertices or faces are stored when building the shape\nmodel except that V[F] yields the faces of the mesh. Vertices\nmay be repeated or not.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>V : array_like\n    An array with shape (num_verts, 3) whose rows correspond to the\n    vertices of the triangle mesh\nF : array_like\n    An array with shape (num_faces, 3) whose rows index the faces\n    of the triangle mesh (i.e., V[F] returns an array with shape\n    (num_faces, 3, 3) such that V[F][i] is a 3x3 matrix whose rows\n    are the vertices of the ith face.\nN : array_like, optional\n    An array with shape (num_faces, 3) consisting of the triangle\n    mesh face normals. Can be passed to specify the face normals.\n    Otherwise, the face normals will be computed from the cross products\n    of the face edges (i.e. np.cross(vi1 - vi0, vi2 - vi0) normalized).\nP : array_like, optional\n    An array with shape (num_faces, 3) consisting of the triangle\n    centroids. Can be optionally passed to avoid recomputing.\nA : array_like, optional\n    An array of shape (num_faces,) containing the triangle areas. Can\n    be optionally passed to avoid recomputing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">F</span>, </span><span class=\"param\"><span class=\"n\">N</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">P</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">A</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.dtype", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.dtype", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.V", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.V", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.F", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.F", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.P", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.P", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.N", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.N", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.A", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.A", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.num_faces", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.num_faces", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.num_verts", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.num_verts", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.intersect1", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.intersect1", "kind": "function", "doc": "<p>Trace a single ray starting from <code>x</code> and in the direction <code>d</code>.  If\nthere is a hit, return the index (<code>i</code>) of the hit and a\nparameter <code>t</code> such that the hit point is given by <code>x(t) = x +\nt*d</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">d</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.intersect1_2d_with_coords", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.intersect1_2d_with_coords", "kind": "function", "doc": "<p>Trace a single ray starting from <code>X</code> and in the direction <code>D</code>.  If\nthere is a hit, return the index (<code>i</code>) of the hit and the coordinates of\nthe centroid of the hit triangle <code>X(t) = X + t*D</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">D</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.TrimeshShapeModel.intersect1_2d", "modulename": "pyRTX.core.utils_rt", "qualname": "TrimeshShapeModel.intersect1_2d", "kind": "function", "doc": "<p>Trace a single ray starting from <code>X</code> and in the direction <code>D</code>.  If\nthere is a hit, return the index (<code>i</code>).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">D</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "pyRTX.core.utils_rt.CgalTrimeshShapeModel", "modulename": "pyRTX.core.utils_rt", "qualname": "CgalTrimeshShapeModel", "kind": "class", "doc": "<p>A shape model consisting of a single triangle mesh.</p>\n", "bases": "TrimeshShapeModel"}, {"fullname": "pyRTX.core.utils_rt.EmbreeTrimeshShapeModel", "modulename": "pyRTX.core.utils_rt", "qualname": "EmbreeTrimeshShapeModel", "kind": "class", "doc": "<p>A shape model consisting of a single triangle mesh.</p>\n", "bases": "TrimeshShapeModel"}, {"fullname": "pyRTX.core.utils_rt.trimesh_shape_models", "modulename": "pyRTX.core.utils_rt", "qualname": "trimesh_shape_models", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&lt;class &#x27;pyRTX.core.utils_rt.CgalTrimeshShapeModel&#x27;&gt;, &lt;class &#x27;pyRTX.core.utils_rt.EmbreeTrimeshShapeModel&#x27;&gt;]"}, {"fullname": "pyRTX.core.utils_rt.RTXkernel", "modulename": "pyRTX.core.utils_rt", "qualname": "RTXkernel", "kind": "function", "doc": "<p>Main ray tracing kernel wrapper supporting multiple ray tracing backends and\nmulti-bounce simulations.</p>\n\n<p>This is the primary interface for performing ray tracing operations in pyRTX.\nIt supports various ray tracing kernels (Embree, CGAL, Native), multiple\nreflection bounces, and optional diffuse scattering for realistic radiation\nmomentum exchange calculatons.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mesh_obj : trimesh.Trimesh\n    The mesh geometry to ray trace against. Must be a valid triangular mesh.\nray_origins : ndarray, shape (N_rays, 3)\n    Starting positions of rays in 3D space (in same coordinate system as mesh).\nray_directions : ndarray, shape (N_rays, 3)\n    Direction vectors of rays. Do not need to be normalized.\nbounces : int, default=1\n    Number of reflection bounces to simulate. bounces=1 means direct\n    illumination only, bounces=2 includes one reflection, etc.\nkernel : str, default='Embree'\n    Ray tracing backend to use:\n    - 'Embree3': Intel Embree library (fastest, recommended)\n    - 'Embree' : Intel Embree library (Version 2, slower than 3)\n    - 'CGAL': CGAL AABB tree implementation (robust, slower)\n    - 'Native': Pure Python implementation (very slow, for reference only)\ndiffusion : bool, default=False\n    If True, compute diffuse (Lambertian) reflections in addition to\n    specular reflections. Only applied to the first bounce. Enables\n    realistic modeling of rough surfaces.\nnum_diffuse : int or None, default=None\n    Number of diffuse samples per intersection point. Required if\n    diffusion=True. Typical values: 10-100 depending on accuracy needs.\nerrorMsg : bool, default=True\n    If True, print warning messages when no intersections are found for\n    a bounce. Set to False to suppress warnings in batch processing.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>index_tri_container : list of ndarrays\n    List containing triangle indices for each bounce. Each element is an\n    array of shape (N_hits_i,) containing indices of faces hit at bounce i.\n    Length equals number of computed bounces (\u2264 bounces parameter).\nindex_ray_container : list of ndarrays\n    List containing ray indices for each bounce. index_ray_container[i]\n    maps from the original ray array to rays that hit at bounce i.\nlocations_container : list of ndarrays\n    List of intersection point coordinates for each bounce. Each element\n    has shape (N_hits_i, 3).\nray_origins_container : list of ndarrays\n    List of ray origin positions for each bounce. Note that\n    ray_origins_container[0] equals the input ray_origins parameter.\nray_directions_container : list of ndarrays\n    List of ray direction vectors for each bounce. Element [0] contains\n    input directions, subsequent elements contain reflected directions.\ndiffusion_pack : list or None\n    If diffusion=True, contains diffuse ray tracing results:\n    [index_tri_diffusion, index_ray_diffusion, ray_directions_diffusion,\n     location_diffusion]. If diffusion=False, returns None.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Algorithm Overview:</p>\n\n<ol>\n<li>Initialize ray tracing kernel (Embree, CGAL, or Native)</li>\n<li>For each bounce:\na. Add small offset to ray origins (avoids self-intersection)\nb. Trace rays to find intersections\nc. If no hits found, terminate and return results up to current bounce\nd. Compute specular reflection directions for next bounce\ne. If diffusion enabled and bounce==1, also compute diffuse reflections</li>\n<li>Return accumulated results for all bounces</li>\n</ol>\n\n<p>Performance Notes:</p>\n\n<ul>\n<li>Embree is typically 10-100\u00d7 faster than Native for large meshes</li>\n<li>CGAL offers good robustness for edge cases but slower than Embree</li>\n<li>Diffusion increases computation by factor of num_diffuse</li>\n<li>Memory usage scales linearly with bounces and num_diffuse</li>\n</ul>\n\n<p>Kernel-Specific Details:</p>\n\n<ul>\n<li>Embree/Embree3: Uses BVH acceleration, highly optimized for x86 CPUs</li>\n<li>CGAL: Uses AABB tree, more robust numerical handling</li>\n<li>Native: Pure Python/Trimesh, no special acceleration</li>\n</ul>\n\n<p>The 1e-3 offset added to ray origins prevents numerical precision issues\nwhere a reflected ray might re-intersect the same surface it just bounced\nfrom (self-intersection artifact).</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Simple direct illumination</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">RTXkernel</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">origins</span><span class=\"p\">,</span> <span class=\"n\">directions</span><span class=\"p\">,</span> <span class=\"n\">bounces</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"o\">=</span><span class=\"s1\">&#39;Embree&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">hits</span><span class=\"p\">,</span> <span class=\"n\">ray_ids</span><span class=\"p\">,</span> <span class=\"n\">locations</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">results</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Multi-bounce with diffuse scattering</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">RTXkernel</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">origins</span><span class=\"p\">,</span> <span class=\"n\">directions</span><span class=\"p\">,</span> <span class=\"n\">bounces</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> \n<span class=\"gp\">... </span>                    <span class=\"n\">kernel</span><span class=\"o\">=</span><span class=\"s1\">&#39;Embree&#39;</span><span class=\"p\">,</span> <span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">hits</span><span class=\"p\">,</span> <span class=\"n\">ray_ids</span><span class=\"p\">,</span> <span class=\"n\">locs</span><span class=\"p\">,</span> <span class=\"n\">origins</span><span class=\"p\">,</span> <span class=\"n\">dirs</span><span class=\"p\">,</span> <span class=\"n\">diffuse_data</span> <span class=\"o\">=</span> <span class=\"n\">results</span>\n</code></pre>\n</div>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>pixel_plane_opt : Generate ray grids for illumination sources\ncompute_secondary_bounce : Compute reflection directions\ndiffuse : Generate diffuse reflection samples</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mesh_obj</span>,</span><span class=\"param\">\t<span class=\"n\">ray_origins</span>,</span><span class=\"param\">\t<span class=\"n\">ray_directions</span>,</span><span class=\"param\">\t<span class=\"n\">bounces</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">kernel</span><span class=\"o\">=</span><span class=\"s1\">&#39;Embree3&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">diffusion</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">num_diffuse</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">errorMsg</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();