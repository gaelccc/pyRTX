

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyRTX.core.utils_rt &mdash; pyRTX 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://gaelccc.github.io/pyRTX/api/generated/pyRTX.core.utils_rt.html" />
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=2389946f"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="pyRTX.classes" href="pyRTX.classes.html" />
    <link rel="prev" title="pyRTX.core.shadow_utils" href="pyRTX.core.shadow_utils.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyRTX
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#from-source">From Source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#dependencies">Dependencies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../installation.html#build-dependencies">Build Dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../installation.html#runtime-dependencies">Runtime Dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#basic-usage">Basic Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../quickstart.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../core.html">Core Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../core.html#module-pyRTX.core.utils_rt">Ray Tracing Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.chunker"><code class="docutils literal notranslate"><span class="pre">chunker()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.pxform_convert"><code class="docutils literal notranslate"><span class="pre">pxform_convert()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.block_normalize"><code class="docutils literal notranslate"><span class="pre">block_normalize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.block_dot"><code class="docutils literal notranslate"><span class="pre">block_dot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.pixel_plane"><code class="docutils literal notranslate"><span class="pre">pixel_plane()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.fast_vector_build"><code class="docutils literal notranslate"><span class="pre">fast_vector_build()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.pixel_plane_opt"><code class="docutils literal notranslate"><span class="pre">pixel_plane_opt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.reflected"><code class="docutils literal notranslate"><span class="pre">reflected()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.get_orthogonal"><code class="docutils literal notranslate"><span class="pre">get_orthogonal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.sample_lambert_dist"><code class="docutils literal notranslate"><span class="pre">sample_lambert_dist()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.diffuse"><code class="docutils literal notranslate"><span class="pre">diffuse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.compute_secondary_bounce"><code class="docutils literal notranslate"><span class="pre">compute_secondary_bounce()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.save_for_visualization"><code class="docutils literal notranslate"><span class="pre">save_for_visualization()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.exportEXAC"><code class="docutils literal notranslate"><span class="pre">exportEXAC()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.Embree3_init_geometry"><code class="docutils literal notranslate"><span class="pre">Embree3_init_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.Embree3_init_rayhit"><code class="docutils literal notranslate"><span class="pre">Embree3_init_rayhit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.Embree3_dump_solution"><code class="docutils literal notranslate"><span class="pre">Embree3_dump_solution()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.cgal_init_geometry"><code class="docutils literal notranslate"><span class="pre">cgal_init_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.get_centroids"><code class="docutils literal notranslate"><span class="pre">get_centroids()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.get_cross_products"><code class="docutils literal notranslate"><span class="pre">get_cross_products()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.get_face_areas"><code class="docutils literal notranslate"><span class="pre">get_face_areas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.get_surface_normals"><code class="docutils literal notranslate"><span class="pre">get_surface_normals()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.get_surface_normals_and_face_areas"><code class="docutils literal notranslate"><span class="pre">get_surface_normals_and_face_areas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.ShapeModel"><code class="docutils literal notranslate"><span class="pre">ShapeModel</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.TrimeshShapeModel"><code class="docutils literal notranslate"><span class="pre">TrimeshShapeModel</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.CgalTrimeshShapeModel"><code class="docutils literal notranslate"><span class="pre">CgalTrimeshShapeModel</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.EmbreeTrimeshShapeModel"><code class="docutils literal notranslate"><span class="pre">EmbreeTrimeshShapeModel</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.utils_rt.RTXkernel"><code class="docutils literal notranslate"><span class="pre">RTXkernel()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../core.html#module-pyRTX.core.shadow_utils">Shadow Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.shadow_utils.circular_mask"><code class="docutils literal notranslate"><span class="pre">circular_mask()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.shadow_utils.circular_rim"><code class="docutils literal notranslate"><span class="pre">circular_rim()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.shadow_utils.compute_directions"><code class="docutils literal notranslate"><span class="pre">compute_directions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.shadow_utils.compute_beta"><code class="docutils literal notranslate"><span class="pre">compute_beta()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.shadow_utils.compute_pixel_intensities"><code class="docutils literal notranslate"><span class="pre">compute_pixel_intensities()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../core.html#module-pyRTX.core.physical_utils">Physical Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.physical_utils.preprocess_RTX_geometry"><code class="docutils literal notranslate"><span class="pre">preprocess_RTX_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.physical_utils.preprocess_materials"><code class="docutils literal notranslate"><span class="pre">preprocess_materials()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.physical_utils.srp_core"><code class="docutils literal notranslate"><span class="pre">srp_core()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.physical_utils.compute_srp"><code class="docutils literal notranslate"><span class="pre">compute_srp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../core.html#module-pyRTX.core.parallel_utils">Parallel Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.parallel_utils.get_ncores"><code class="docutils literal notranslate"><span class="pre">get_ncores()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.parallel_utils.is_method"><code class="docutils literal notranslate"><span class="pre">is_method()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.parallel_utils.get_unwrapped"><code class="docutils literal notranslate"><span class="pre">get_unwrapped()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../core.html#pyRTX.core.parallel_utils.parallel"><code class="docutils literal notranslate"><span class="pre">parallel()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../classes.html">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../classes.html#sunshadow">SunShadow</a></li>
<li class="toctree-l3"><a class="reference internal" href="../classes.html#solarpressure">SolarPressure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../classes.html#pyRTX.classes.SRP.SolarPressure"><code class="docutils literal notranslate"><span class="pre">SolarPressure</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../classes.html#planet">Planet</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../classes.html#pyRTX.classes.Planet.Planet"><code class="docutils literal notranslate"><span class="pre">Planet</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../classes.html#pixelplane">PixelPlane</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../classes.html#pyRTX.classes.PixelPlane.PixelPlane"><code class="docutils literal notranslate"><span class="pre">PixelPlane</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../classes.html#spacecraft">Spacecraft</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../classes.html#pyRTX.classes.Spacecraft.Spacecraft"><code class="docutils literal notranslate"><span class="pre">Spacecraft</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../defaults.html">Default Values and Constants</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#core-modules">Core Modules</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pyRTX.core.html">pyRTX.core</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="pyRTX.core.analysis_utils.html">pyRTX.core.analysis_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.core.parallel_utils.html">pyRTX.core.parallel_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.core.physical_utils.html">pyRTX.core.physical_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.core.shadow_utils.html">pyRTX.core.shadow_utils</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">pyRTX.core.utils_rt</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pyRTX.classes.html">pyRTX.classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.Atmosphere.html">pyRTX.classes.Atmosphere</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.Drag.html">pyRTX.classes.Drag</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.LookUpTable.html">pyRTX.classes.LookUpTable</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.PixelPlane.html">pyRTX.classes.PixelPlane</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.Planet.html">pyRTX.classes.Planet</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.Precompute.html">pyRTX.classes.Precompute</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.Radiation.html">pyRTX.classes.Radiation</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.RayTracer.html">pyRTX.classes.RayTracer</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.SRP.html">pyRTX.classes.SRP</a></li>
<li class="toctree-l4"><a class="reference internal" href="pyRTX.classes.Spacecraft.html">pyRTX.classes.Spacecraft</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyRTX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="pyRTX.core.html">pyRTX.core</a></li>
      <li class="breadcrumb-item active">pyRTX.core.utils_rt</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api/generated/pyRTX.core.utils_rt.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pyRTX.core.utils_rt">
<span id="pyrtx-core-utils-rt"></span><h1>pyRTX.core.utils_rt<a class="headerlink" href="#module-pyRTX.core.utils_rt" title="Permalink to this heading"></a></h1>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.Embree3_dump_solution" title="pyRTX.core.utils_rt.Embree3_dump_solution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Embree3_dump_solution</span></code></a>(rayhit, V, F)</p></td>
<td><p>Extract and process ray-surface intersection results from Embree RayHit structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.Embree3_init_geometry" title="pyRTX.core.utils_rt.Embree3_init_geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Embree3_init_geometry</span></code></a>(mesh_obj)</p></td>
<td><p>Initialize mesh geometry for ray tracing using the Embree 3 ray tracing kernel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.Embree3_init_rayhit" title="pyRTX.core.utils_rt.Embree3_init_rayhit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Embree3_init_rayhit</span></code></a>(ray_origins, ray_directions)</p></td>
<td><p>Initialize Embree 3 RayHit data structure for ray tracing queries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.RTXkernel" title="pyRTX.core.utils_rt.RTXkernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RTXkernel</span></code></a>(mesh_obj, ray_origins, ray_directions)</p></td>
<td><p>Main ray tracing kernel wrapper supporting multiple ray tracing backends and multi-bounce simulations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.block_dot" title="pyRTX.core.utils_rt.block_dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block_dot</span></code></a>(a, b)</p></td>
<td><p>Perform element-wise dot product between corresponding vectors in two arrays.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.block_normalize" title="pyRTX.core.utils_rt.block_normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">block_normalize</span></code></a>(V)</p></td>
<td><p>Compute unit vectors for a block of vectors efficiently using vectorized operations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.cgal_init_geometry" title="pyRTX.core.utils_rt.cgal_init_geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cgal_init_geometry</span></code></a>(mesh_obj)</p></td>
<td><p>Initialize mesh geometry for ray tracing using the CGAL (Computational Geometry Algorithms Library) ray tracing kernel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.chunker" title="pyRTX.core.utils_rt.chunker"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chunker</span></code></a>(iterator, chunks)</p></td>
<td><p>Divide an iterator or array into approximately equal-sized chunks for parallel processing.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.compute_secondary_bounce" title="pyRTX.core.utils_rt.compute_secondary_bounce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_secondary_bounce</span></code></a>(location, ...[, ...])</p></td>
<td><p>Prepare ray origins and directions for subsequent ray tracing bounces by computing specular and optionally diffuse reflection directions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.diffuse" title="pyRTX.core.utils_rt.diffuse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diffuse</span></code></a>(normals[, num])</p></td>
<td><p>Compute multiple diffuse reflection directions for an array of surface normals by sampling the Lambert cosine distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.exportEXAC" title="pyRTX.core.utils_rt.exportEXAC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exportEXAC</span></code></a>(satelliteID, data, tstep, ...)</p></td>
<td><p>Export acceleration data to GEODYN EXAC (External Accelerations) file format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.fast_vector_build" title="pyRTX.core.utils_rt.fast_vector_build"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_vector_build</span></code></a>(linsp1, linsp2, dim1, dim2)</p></td>
<td><p>Efficiently build a pixel array coordinate grid using Numba's JIT compilation for performance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.get_centroids" title="pyRTX.core.utils_rt.get_centroids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_centroids</span></code></a>(V, F)</p></td>
<td><p>Compute the geometric centroids of all triangular faces in a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.get_cross_products" title="pyRTX.core.utils_rt.get_cross_products"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cross_products</span></code></a>(V, F)</p></td>
<td><p>Compute cross products of edge vectors for all triangular faces in a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.get_face_areas" title="pyRTX.core.utils_rt.get_face_areas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_face_areas</span></code></a>(V, F)</p></td>
<td><p>Compute the areas of all triangular faces in a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.get_orthogonal" title="pyRTX.core.utils_rt.get_orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_orthogonal</span></code></a>(v)</p></td>
<td><p>Generate a unit vector orthogonal to the input vector using randomization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.get_surface_normals" title="pyRTX.core.utils_rt.get_surface_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_surface_normals</span></code></a>(V, F)</p></td>
<td><p>Compute outward-pointing unit normal vectors for all triangular faces.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.get_surface_normals_and_face_areas" title="pyRTX.core.utils_rt.get_surface_normals_and_face_areas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_surface_normals_and_face_areas</span></code></a>(V, F)</p></td>
<td><p>Efficiently compute both surface normals and face areas simultaneously.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.pixel_plane" title="pyRTX.core.utils_rt.pixel_plane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pixel_plane</span></code></a>(d0, lon, lat[, width, height, ...])</p></td>
<td><p>Generate a rectangular pixel array (grid of rays) for ray tracing, as defined in Li et al., 2018.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.pixel_plane_opt" title="pyRTX.core.utils_rt.pixel_plane_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pixel_plane_opt</span></code></a>(d0, lon, lat[, width, ...])</p></td>
<td><p>Generate a rectangular pixel array for ray tracing - optimized version with optional ray packet subdivision.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.pxform_convert" title="pyRTX.core.utils_rt.pxform_convert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pxform_convert</span></code></a>(pxform)</p></td>
<td><p>Convert a SPICE-generated rotation matrix (pxform) to the 4x4 homogeneous transformation matrix format required by trimesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.reflected" title="pyRTX.core.utils_rt.reflected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reflected</span></code></a>(incoming, normal)</p></td>
<td><p>Compute reflected ray directions given incoming rays and surface normals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.sample_lambert_dist" title="pyRTX.core.utils_rt.sample_lambert_dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_lambert_dist</span></code></a>(normal[, num])</p></td>
<td><p>Generate a cloud of direction vectors following the Lambert cosine distribution (also known as Lambertian distribution or cosine-weighted hemisphere sampling).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.save_for_visualization" title="pyRTX.core.utils_rt.save_for_visualization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_for_visualization</span></code></a>(outputFilePath, mesh, ...)</p></td>
<td><p>Save ray tracing results to a pickled dictionary for post-processing and visualization.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.CgalTrimeshShapeModel" title="pyRTX.core.utils_rt.CgalTrimeshShapeModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CgalTrimeshShapeModel</span></code></a>(V, F[, N, P, A])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.EmbreeTrimeshShapeModel" title="pyRTX.core.utils_rt.EmbreeTrimeshShapeModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EmbreeTrimeshShapeModel</span></code></a>(V, F[, N, P, A])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.ShapeModel" title="pyRTX.core.utils_rt.ShapeModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShapeModel</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyRTX.core.utils_rt.TrimeshShapeModel" title="pyRTX.core.utils_rt.TrimeshShapeModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TrimeshShapeModel</span></code></a>(V, F[, N, P, A])</p></td>
<td><p>A shape model consisting of a single triangle mesh.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.chunker">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">chunker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#chunker"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.chunker" title="Permalink to this definition"></a></dt>
<dd><p>Divide an iterator or array into approximately equal-sized chunks for
parallel processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterator</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – The array-like object to divide into chunks.</p></li>
<li><p><strong>chunks</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Number of chunks to create.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – List containing the chunked arrays. Chunks will be approximately equal
in size, with the last chunk potentially being smaller.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">arrays</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Uses numpy.array_split which handles uneven divisions automatically.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.pxform_convert">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">pxform_convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pxform</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#pxform_convert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.pxform_convert" title="Permalink to this definition"></a></dt>
<dd><p>Convert a SPICE-generated rotation matrix (pxform) to the 4x4 homogeneous
transformation matrix format required by trimesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pxform</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – The 3x3 rotation matrix from SPICE (obtained via spiceypy.pxform).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The 4x4 homogeneous transformation matrix with the rotation in the
upper-left 3x3 block, zeros in the translation column, and [0,0,0,0]
in the bottom row.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">4)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Trimesh uses 4x4 homogeneous transformation matrices for geometric operations.
This function adds the necessary padding to convert a pure rotation matrix.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.block_normalize">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">block_normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#block_normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.block_normalize" title="Permalink to this definition"></a></dt>
<dd><p>Compute unit vectors for a block of vectors efficiently using vectorized
operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">(3,)</span></code>) – Array of vectors to normalize. Can be a single vector or multiple vectors.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – The normalized vectors (unit vectors with magnitude 1).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">same</span> <span class="pre">shape</span> <span class="pre">as</span> <span class="pre">V</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Uses vectorized numpy operations for efficiency with large arrays. Handles
both single vectors and arrays of vectors automatically.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.block_dot">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">block_dot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#block_dot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.block_dot" title="Permalink to this definition"></a></dt>
<dd><p>Perform element-wise dot product between corresponding vectors in two arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">m)</span></code>) – First array of vectors.</p></li>
<li><p><strong>b</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">m)</span></code>) – Second array of vectors (must have same shape as a).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – Array containing the dot product of each pair of corresponding vectors.
result[i] = a[i] · b[i]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N,)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This is more efficient than using a loop for computing many dot products.
Equivalent to np.einsum(‘ij,ij-&gt;i’, a, b) but more readable.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.pixel_plane">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">pixel_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#pixel_plane"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.pixel_plane" title="Permalink to this definition"></a></dt>
<dd><p>Generate a rectangular pixel array (grid of rays) for ray tracing, as defined
in Li et al., 2018. This is the explicit implementation showing the full
algorithm.</p>
<p>This function creates a planar grid of ray origins and directions pointing
toward a specified direction in 3D space, useful for simulating parallel
light sources like the Sun.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Distance of the pixel plane from the origin (in meters). This defines
how far the ray origins are from the coordinate system origin.</p></li>
<li><p><strong>lon</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Longitude of the pixel plane’s center direction (in radians). Defines
the azimuthal angle in spherical coordinates.</p></li>
<li><p><strong>lat</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Latitude of the pixel plane’s center direction (in radians). Defines
the elevation angle in spherical coordinates.</p></li>
<li><p><strong>width</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Width of the plane (in meters). The plane extends ±width/2 in the
horizontal direction.</p></li>
<li><p><strong>height</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Height of the plane (in meters). The plane extends ±height/2 in the
vertical direction.</p></li>
<li><p><strong>ray_spacing</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">0.1</span></code>) – Spacing between adjacent rays (in meters). Smaller values create denser
ray grids but increase computation time.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>locs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Ray origin positions in 3D space. N = (width/ray_spacing + 1) ×
(height/ray_spacing + 1).</p></li>
<li><p><strong>dirs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Ray direction unit vectors. All rays point toward the origin (or away
from the direction specified by lon/lat).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The pixel plane is oriented perpendicular to the direction vector defined
by (lon, lat) and positioned at distance d0 from the origin. This creates
a uniform grid of parallel rays suitable for simulating distant light sources.</p>
<p>For performance-critical applications, use pixel_plane_opt instead.</p>
</div>
<div class="admonition-references admonition">
<p class="admonition-title">References</p>
<p>Li et al., 2018 - Solar radiation pressure modeling methodology</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.fast_vector_build">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">fast_vector_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linsp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linsp2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#fast_vector_build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.fast_vector_build" title="Permalink to this definition"></a></dt>
<dd><p>Efficiently build a pixel array coordinate grid using Numba’s JIT compilation
for performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linsp1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(dim1,)</span></code>) – Linear space defining positions along the first dimension (typically width).</p></li>
<li><p><strong>linsp2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(dim2,)</span></code>) – Linear space defining positions along the second dimension (typically height).</p></li>
<li><p><strong>dim1</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Number of points in the first dimension.</p></li>
<li><p><strong>dim2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Number of points in the second dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – Array of 3D coordinates forming a rectangular grid in the y-z plane
(x=0 for all points). The grid is built by nested iteration over linsp1
and linsp2.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(dim1</span> <span class="pre">×</span> <span class="pre">dim2</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This function is JIT-compiled with Numba for significant performance improvement
over pure Python loops. Used internally by pixel_plane_opt.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.pixel_plane_opt">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">pixel_plane_opt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">packets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#pixel_plane_opt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.pixel_plane_opt" title="Permalink to this definition"></a></dt>
<dd><p>Generate a rectangular pixel array for ray tracing - optimized version with
optional ray packet subdivision.</p>
<p>This is a performance-optimized implementation of pixel_plane that uses
vectorized operations and Numba JIT compilation. It also supports dividing
the rays into packets to avoid segmentation faults with very large ray counts.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Distance of the pixel plane from the origin (in meters).</p></li>
<li><p><strong>lon</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Longitude of the pixel plane’s center direction (in radians).</p></li>
<li><p><strong>lat</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Latitude of the pixel plane’s center direction (in radians).</p></li>
<li><p><strong>width</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Width of the plane (in meters).</p></li>
<li><p><strong>height</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Height of the plane (in meters).</p></li>
<li><p><strong>ray_spacing</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">0.1</span></code>) – Spacing between adjacent rays (in meters). Determines ray grid density.</p></li>
<li><p><strong>packets</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Number of ray packets to subdivide the rays into. Use values &gt; 1 to
avoid segmentation faults or memory issues with very large numbers of
rays (typically &gt; 10^6). Each packet is processed separately by the
ray tracer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>locs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – Ray origin positions. If packets=1, returns single array of shape (N, 3).
If packets&gt;1, returns list of arrays, each containing a subset of rays.</p></li>
<li><p><strong>dirs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – Ray direction unit vectors. Same structure as locs.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This is the recommended function for pixel plane generation due to its
performance optimizations. Use packets &gt; 1 when dealing with very dense
ray grids (small ray_spacing values).</p>
<p>The function uses Numba JIT compilation via fast_vector_build for efficient
coordinate grid generation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.reflected">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">reflected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">incoming</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#reflected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.reflected" title="Permalink to this definition"></a></dt>
<dd><p>Compute reflected ray directions given incoming rays and surface normals.
Uses the law of reflection: r = i - 2(i·n)n</p>
<p>This is a vectorized implementation using numpy.einsum for efficient
computation of many reflections simultaneously.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incoming</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Incoming ray direction vectors (do not need to be normalized).</p></li>
<li><p><strong>normal</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Surface normal vectors at reflection points (should be unit vectors).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>reflected</strong> – Reflected ray direction vectors. These are NOT normalized - maintain
the same magnitude as the incoming vectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The reflection formula used is: r = i - 2(i·n)n, where:
- i is the incoming direction
- n is the surface normal
- r is the reflected direction</p>
<p>This formula gives the specular (mirror-like) reflection direction.
Uses np.einsum for efficient vectorized dot product computation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.get_orthogonal">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">get_orthogonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#get_orthogonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.get_orthogonal" title="Permalink to this definition"></a></dt>
<dd><p>Generate a unit vector orthogonal to the input vector using randomization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(3,)</span></code>) – Input vector to which the result should be orthogonal.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x</strong> – Unit vector orthogonal to v (x · v = 0 and ||x|| = 1).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(3,)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Uses a random vector projection method: generates a random 3D vector,
projects out the component parallel to v, and normalizes. This is used
internally for constructing local coordinate systems on surface normals.</p>
<p>JIT-compiled with Numba for performance.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.sample_lambert_dist">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">sample_lambert_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#sample_lambert_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.sample_lambert_dist" title="Permalink to this definition"></a></dt>
<dd><p>Generate a cloud of direction vectors following the Lambert cosine
distribution (also known as Lambertian distribution or cosine-weighted
hemisphere sampling).</p>
<p>The Lambert distribution models ideal diffuse reflection where the
probability of a ray being reflected in a given direction is proportional
to the cosine of the angle between that direction and the surface normal.
This is physically accurate for perfectly diffuse (Lambertian) surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(3,)</span></code>) – Surface normal vector defining the hemisphere orientation (should be
a unit vector).</p></li>
<li><p><strong>num</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">100</span></code>) – Number of sample directions to generate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>v</strong> – Array of sampled direction vectors distributed according to Lambert’s
cosine law. All vectors point into the hemisphere defined by the normal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(num</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The sampling uses spherical coordinates with:
- θ (polar angle): sampled as θ = arccos(√ξ) where ξ ~ U(0,1)
- ψ (azimuthal angle): sampled uniformly as ψ ~ U(0, 2π)</p>
<p>This ensures that the probability density is proportional to cos(θ), which
is characteristic of ideal diffuse reflection (Lambert’s cosine law).</p>
<p>JIT-compiled with Numba for performance. Used for modeling diffuse
reflection in ray tracing.</p>
</div>
<div class="admonition-references admonition">
<p class="admonition-title">References</p>
<p>Lambert’s Cosine Law: I = I₀ cos(θ) where θ is the angle from the normal</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.diffuse">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">diffuse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#diffuse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.diffuse" title="Permalink to this definition"></a></dt>
<dd><p>Compute multiple diffuse reflection directions for an array of surface
normals by sampling the Lambert cosine distribution.</p>
<p>For each input normal, generates num diffusely reflected ray directions
following Lambert’s cosine law. This models realistic diffuse scattering
from rough surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Array of surface normal unit vectors at reflection points.</p></li>
<li><p><strong>num</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">10</span></code>) – Number of diffuse samples to generate for each normal. Higher values
give more accurate diffuse reflection modeling but increase computation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>diffuse_directions</strong> – Array of sampled diffuse direction vectors. For each of the N input
normals, generates num directions, resulting in N×num total directions.
Directions are ordered so that directions [i×num : (i+1)×num] correspond
to normal i.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span> <span class="pre">×</span> <span class="pre">num</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This function is used to model non-specular (rough) surface reflections.
Each diffuse direction is randomly sampled from the hemisphere above the
surface, weighted by the cosine of the angle from the normal (Lambert’s law).</p>
<p>The returned array can be fed directly into the ray tracer to simulate
secondary illumination from diffuse reflections.</p>
</div>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># Two normals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dirs</span> <span class="o">=</span> <span class="n">diffuse</span><span class="p">(</span><span class="n">normals</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 5 samples each</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dirs</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3)  # 2 normals × 5 samples = 10 directions</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.compute_secondary_bounce">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">compute_secondary_bounce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_tri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_ray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffusion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_diffuse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#compute_secondary_bounce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.compute_secondary_bounce" title="Permalink to this definition"></a></dt>
<dd><p>Prepare ray origins and directions for subsequent ray tracing bounces by
computing specular and optionally diffuse reflection directions.</p>
<p>This function takes the results of a ray-surface intersection and computes
the reflected rays needed for the next bounce iteration in multi-bounce
ray tracing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>location</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – 3D coordinates of ray-surface intersection points.</p></li>
<li><p><strong>index_tri</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits,)</span></code>) – Indices of the mesh faces (triangles) that were intersected by rays.</p></li>
<li><p><strong>mesh_obj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.Trimesh</span></code>) – The mesh object containing geometry information (vertices, faces, normals).</p></li>
<li><p><strong>ray_directions</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_rays</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Direction vectors of the incident rays (before intersection).</p></li>
<li><p><strong>index_ray</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits,)</span></code>) – Indices of the rays that successfully intersected the mesh. Used to
map from the original ray array to the subset that hit surfaces.</p></li>
<li><p><strong>diffusion</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>default</em> <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a>) – If True, compute diffuse reflection directions in addition to specular
reflections. Used for modeling rough surface scattering.</p></li>
<li><p><strong>num_diffuse</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, <em>default</em> <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>) – Number of diffuse samples per intersection point. Required if
diffusion=True, ignored otherwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>location</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Same as input location (pass-through for convenience).</p></li>
<li><p><strong>reflect_dirs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Specularly reflected ray directions for each intersection point.
Computed using the law of reflection with surface normals.</p></li>
<li><p><strong>diffuse_dirs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits</span> <span class="pre">×</span> <span class="pre">num_diffuse</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – If diffusion=True: array of diffusely reflected directions sampled
from Lambert distribution for each intersection point.
If diffusion=False: returns -1 (dummy value for consistent return signature).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This function is typically called iteratively in multi-bounce ray tracing:
1. First bounce: rays from source hit surface
2. Compute secondary bounces from intersection points
3. Trace secondary rays
4. Repeat for N bounces</p>
<p>The specular reflections follow the law of reflection, while diffuse
reflections sample the Lambert cosine distribution, providing physically
accurate modeling of both mirror-like and rough surfaces.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.save_for_visualization">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">save_for_visualization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outputFilePath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_origins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_tri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffusion_pack</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#save_for_visualization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.save_for_visualization" title="Permalink to this definition"></a></dt>
<dd><p>Save ray tracing results to a pickled dictionary for post-processing and
visualization.</p>
<p>Creates a standardized output format that can be loaded by visualization
scripts (see visual_utils module) for analyzing ray tracing results,
creating visualizations, and debugging ray path geometries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outputFilePath</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) – Path to output file. Should end with ‘.pkl’ extension. Parent directory
must exist.</p></li>
<li><p><strong>mesh</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.Trimesh</span></code>) – The mesh object that was ray-traced. Contains geometry (vertices, faces,
normals) for visualization.</p></li>
<li><p><strong>ray_origins</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List containing ray origin arrays for each bounce. Each element is an
array of shape (N_rays_i, 3) where i is the bounce number.</p></li>
<li><p><strong>ray_directions</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List containing ray direction arrays for each bounce. Same structure
as ray_origins.</p></li>
<li><p><strong>location</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List containing intersection point coordinates for each bounce. Each
element is shape (N_hits_i, 3).</p></li>
<li><p><strong>index_tri</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List containing indices of intersected triangles for each bounce.
Each element is shape (N_hits_i,).</p></li>
<li><p><strong>diffusion_pack</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>) – <p>Diffuse ray tracing data if computed, otherwise None. Contains:
[index_tri_diffusion, index_ray_diffusion, ray_directions_diffusion,</p>
<blockquote>
<div><p>location_diffusion] for visualization of diffuse scattering.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Data is written to file at outputFilePath.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The output file contains a dictionary with keys:
- ‘mesh’: trimesh.Trimesh object
- ‘ray_origins’: list of origin arrays per bounce
- ‘ray_directions’: list of direction arrays per bounce
- ‘locations’: list of intersection point arrays per bounce
- ‘index_tri’: list of triangle index arrays per bounce
- ‘diffusion_pack’: diffuse ray data or None</p>
<p>This standardized format allows visualization scripts to recreate the full
ray tracing geometry including multiple bounces and diffuse scattering.</p>
<p>The file is saved using pickle protocol 4 for Python 3 compatibility.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.exportEXAC">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">exportEXAC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">satelliteID</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tstep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">startTime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endTime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outFileName</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#exportEXAC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.exportEXAC" title="Permalink to this definition"></a></dt>
<dd><p>Export acceleration data to GEODYN EXAC (External Accelerations) file format.</p>
<p>GEODYN is NASA’s precision orbit determination software. The EXAC format is
a Fortran-formatted binary file used to provide time-varying external
accelerations (such as solar radiation pressure) to the orbit propagator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>satelliteID</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Satellite identifier code used in GEODYN processing.</p></li>
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Acceleration data to be written, in km/s². Each row is [ax, ay, az]
at one time step.</p></li>
<li><p><strong>tstep</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) – Time step between data records in seconds (e.g., 60 for 1-minute data).</p></li>
<li><p><strong>startTime</strong> (<a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>) – Start time of the data series. Must include date and time information
down to microseconds.</p></li>
<li><p><strong>endTime</strong> (<a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>) – End time of the data series. Must be consistent with len(data) and tstep.</p></li>
<li><p><strong>outFileName</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) – Path to output EXAC file. Typically uses .exac or .bin extension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Data is written to binary file at outFileName.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>EXAC File Structure:
- Master header record: Control parameters and file type identifier
- Satellite-specific header: Satellite ID, time step, start/end times
- Data records: Time stamp + 3D acceleration vector + padding zeros</p>
<p>Time Format:
- Stored as YYMMDDHHMMSSμμμμμμ (year-month-day-hour-minute-second-microsecond)
- Year uses 2-digit format (YY)</p>
<p>Coordinate System:
- Accelerations should be in the same reference frame as the GEODYN</p>
<blockquote>
<div><p>orbit integration (typically J2000 or ICRF)</p>
</div></blockquote>
<p>Units:
- Accelerations: km/s²
- Time step: seconds</p>
<p>This format is used for high-precision orbit determination where external
non-gravitational forces (solar pressure, atmospheric drag, etc.) need to
be accurately modeled.</p>
<p>Requires scipy.io.FortranFile for binary I/O operations.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.Embree3_init_geometry">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">Embree3_init_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#Embree3_init_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.Embree3_init_geometry" title="Permalink to this definition"></a></dt>
<dd><p>Initialize mesh geometry for ray tracing using the Embree 3 ray tracing kernel.</p>
<p>Converts a trimesh mesh object into an EmbreeTrimeshShapeModel that can be
efficiently ray-traced using Intel’s Embree library. Precomputes surface
normals and face areas for performance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mesh_obj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.Trimesh</span></code>) – Input mesh object containing vertices and faces. Must be a valid
triangular mesh.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>scene</strong> – Shape model object containing:
- V: vertex coordinates array
- F: face index array
- N: face normal vectors
- A: face areas
- scene: Embree scene object for ray tracing</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyRTX.core.utils_rt.EmbreeTrimeshShapeModel" title="pyRTX.core.utils_rt.EmbreeTrimeshShapeModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmbreeTrimeshShapeModel</span></code></a></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This function performs initial geometry setup required by Embree:
1. Extracts vertices (V) and faces (F) from mesh
2. Computes face normals (N) and areas (A)
3. Creates Embree device, geometry, and scene objects
4. Loads vertex and index buffers into Embree</p>
<p>The returned object can be used with Embree’s ray intersection functions
for high-performance ray tracing. Embree uses hardware-accelerated BVH
(Bounding Volume Hierarchy) structures for fast ray-triangle intersections.</p>
<p>NOTE: The Embree 3 wrapper functions were developed by Sam Potter
(<a class="reference external" href="https://github.com/sampotter/python-embree">https://github.com/sampotter/python-embree</a>)</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.EmbreeTrimeshShapeModel" title="pyRTX.core.utils_rt.EmbreeTrimeshShapeModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EmbreeTrimeshShapeModel</span></code></a></dt><dd><p>The shape model class</p>
</dd>
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.RTXkernel" title="pyRTX.core.utils_rt.RTXkernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RTXkernel</span></code></a></dt><dd><p>Main ray tracing interface</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.Embree3_init_rayhit">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">Embree3_init_rayhit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ray_origins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#Embree3_init_rayhit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.Embree3_init_rayhit" title="Permalink to this definition"></a></dt>
<dd><p>Initialize Embree 3 RayHit data structure for ray tracing queries.</p>
<p>Creates and configures an Embree RayHit1M object that stores ray information
(origins, directions, parameters) and will be populated with hit information
(intersection distances, geometry IDs) by the ray tracer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ray_origins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Starting positions of rays in 3D space.</p></li>
<li><p><strong>ray_directions</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Direction vectors of rays (do not need to be normalized; Embree handles
this internally).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rayhit</strong> – Initialized RayHit structure containing:
- org: ray origin coordinates (set from ray_origins)
- dir: ray direction vectors (set from ray_directions)
- tnear: minimum ray parameter (set to 0.0 to trace from origin)
- tfar: maximum ray parameter (set to infinity for unbounded rays)
- prim_id: primitive (triangle) ID (initialized to INVALID, filled by tracer)
- geom_id: geometry ID (initialized to INVALID, filled by tracer)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">embree.RayHit1M</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The RayHit1M structure supports tracing multiple rays simultaneously (the “1M”
indicates “1 Million” rays capability). After calling Embree’s intersect
function, the structure will contain:
- Updated tnear/tfar values indicating intersection distances
- prim_id: index of intersected triangle (-1 if no hit)
- geom_id: geometry identifier (-1 if no hit)
- uv: barycentric coordinates of intersection point within triangle</p>
<p>The tnear parameter is set to 0.0 rather than a small epsilon to avoid
missing intersections, but this may cause numerical issues with very close
surfaces. Adjust if needed for specific applications.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.Embree3_dump_solution">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">Embree3_dump_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rayhit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#Embree3_dump_solution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.Embree3_dump_solution" title="Permalink to this definition"></a></dt>
<dd><p>Extract and process ray-surface intersection results from Embree RayHit structure.</p>
<p>After Embree’s ray tracing kernel completes, this function extracts the
intersection data and converts it into standard numpy arrays. It computes
actual 3D intersection point coordinates from barycentric coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rayhit</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">embree.RayHit1M</span></code>) – RayHit structure populated by Embree’s intersect function, containing
primitive IDs, geometry IDs, barycentric coordinates, etc.</p></li>
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_vertices</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Vertex coordinates of the mesh.</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Face indices of the mesh (each row contains indices of 3 vertices
forming a triangle).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>hits</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits,)</span></code> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Indices of triangles that were intersected. Returns -1 if no hits.</p></li>
<li><p><strong>nhits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Number of rays that intersected the mesh. Returns -1 if no hits.</p></li>
<li><p><strong>idh</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits,)</span></code> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – Indices of rays that successfully hit the mesh (mapping from original
ray array to hit subset). Returns -1 if no hits.</p></li>
<li><p><strong>Ph</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_hits</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – 3D coordinates of intersection points computed from barycentric
coordinates. Returns -1 if no hits.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The function identifies valid hits by checking if prim_id != INVALID_GEOMETRY_ID.</p>
<dl class="simple">
<dt>For valid hits, intersection points are computed using barycentric interpolation:</dt><dd><p>Ph = v1 + (v2 - v1) * u + (v3 - v1) * v</p>
</dd>
</dl>
<p>where:
- v1, v2, v3 are the triangle vertices
- u, v are barycentric coordinates from rayhit.uv
- Ph is the 3D intersection point</p>
<p>If no intersections occurred (nhits=0), all return values are -1 to indicate
no valid data.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.cgal_init_geometry">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">cgal_init_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#cgal_init_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.cgal_init_geometry" title="Permalink to this definition"></a></dt>
<dd><p>Initialize mesh geometry for ray tracing using the CGAL (Computational Geometry
Algorithms Library) ray tracing kernel.</p>
<p>Converts a trimesh mesh object into a CgalTrimeshShapeModel that uses CGAL’s
AABB (Axis-Aligned Bounding Box) tree for efficient ray-triangle intersections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mesh_obj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.Trimesh</span></code>) – Input mesh object containing vertices and faces.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>CgalTrimeshShapeModel</strong> – Shape model configured for CGAL ray tracing, containing:
- V: vertex coordinates
- F: face indices
- N: face normals
- A: face areas
- aabb: CGAL AABB tree structure for fast queries</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">model</span> <span class="pre">object</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>CGAL is a C++ library providing robust geometric algorithms. The AABB tree
structure enables efficient ray tracing through hierarchical spatial subdivision.</p>
<p>This function is adapted from python-flux. CGAL may be more robust than
Embree for certain edge cases (nearly degenerate triangles, numerical precision
issues) but is typically slower for large numbers of rays.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.CgalTrimeshShapeModel" title="pyRTX.core.utils_rt.CgalTrimeshShapeModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CgalTrimeshShapeModel</span></code></a></dt><dd><p>The CGAL-based shape model class</p>
</dd>
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.RTXkernel" title="pyRTX.core.utils_rt.RTXkernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RTXkernel</span></code></a></dt><dd><p>Main ray tracing interface that can use CGAL kernel</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.get_centroids">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">get_centroids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#get_centroids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.get_centroids" title="Permalink to this definition"></a></dt>
<dd><p>Compute the geometric centroids of all triangular faces in a mesh.</p>
<p>The centroid of a triangle is the arithmetic mean of its three vertices,
representing the triangle’s center of mass (assuming uniform density).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_vertices</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Vertex coordinates of the mesh.</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Face indices. Each row contains three vertex indices forming a triangle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>P</strong> – Centroid coordinates for each face. P[i] = (V[F[i][0]] + V[F[i][1]] +
V[F[i][2]]) / 3</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Uses vectorized numpy operations: V[F] creates shape (N_faces, 3, 3) array
where V[F][i] is the 3×3 matrix of vertices for face i. Taking mean along
axis=1 computes centroids efficiently for all faces simultaneously.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.get_cross_products">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">get_cross_products</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#get_cross_products"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.get_cross_products" title="Permalink to this definition"></a></dt>
<dd><p>Compute cross products of edge vectors for all triangular faces in a mesh.</p>
<p>For each triangle, computes the cross product of two edge vectors. The
magnitude of this cross product equals twice the triangle’s area, and its
direction is perpendicular to the triangle plane (unnormalized normal).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_vertices</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Vertex coordinates of the mesh.</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Face indices. Each row contains three vertex indices [v0, v1, v2].</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>C</strong> – Cross product vectors for each face. C[i] = (v1 - v0) × (v2 - v0)
where v0, v1, v2 are the vertices of triangle i.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Used internally by get_face_areas and get_surface_normals for efficient
vectorized computation of geometric properties.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.get_face_areas">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">get_face_areas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#get_face_areas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.get_face_areas" title="Permalink to this definition"></a></dt>
<dd><p>Compute the areas of all triangular faces in a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_vertices</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Vertex coordinates of the mesh.</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Face indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>A</strong> – Area of each face in the same units as V (e.g., if V is in meters,
areas are in square meters).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces,)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.get_surface_normals">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">get_surface_normals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#get_surface_normals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.get_surface_normals" title="Permalink to this definition"></a></dt>
<dd><p>Compute outward-pointing unit normal vectors for all triangular faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_vertices</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Vertex coordinates of the mesh.</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Face indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>N</strong> – Unit normal vectors perpendicular to each face. Direction follows
right-hand rule with respect to vertex ordering in F.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.get_surface_normals_and_face_areas">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">get_surface_normals_and_face_areas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#get_surface_normals_and_face_areas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.get_surface_normals_and_face_areas" title="Permalink to this definition"></a></dt>
<dd><p>Efficiently compute both surface normals and face areas simultaneously.</p>
<p>This is more efficient than calling get_surface_normals and get_face_areas
separately because it computes the cross products only once.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_vertices</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Vertex coordinates of the mesh.</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Face indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>N</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Unit normal vectors for each face.</p></li>
<li><p><strong>A</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_faces,)</span></code>) – Area of each face.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Computation steps:
1. Compute cross products C = (v1 - v0) × (v2 - v0)
2. Compute magnitudes ||C||
3. Normals: N = C / ||C||
4. Areas: A = ||C|| / 2</p>
<p>This is the recommended function when both quantities are needed, as it
avoids redundant cross product calculations.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.ShapeModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">ShapeModel</span></span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#ShapeModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.ShapeModel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">TrimeshShapeModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#TrimeshShapeModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel" title="Permalink to this definition"></a></dt>
<dd><p>A shape model consisting of a single triangle mesh.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#TrimeshShapeModel.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a triangle mesh shape model. No assumption is made about
the way vertices or faces are stored when building the shape
model except that V[F] yields the faces of the mesh. Vertices
may be repeated or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – An array with shape (num_verts, 3) whose rows correspond to the
vertices of the triangle mesh</p></li>
<li><p><strong>F</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – An array with shape (num_faces, 3) whose rows index the faces
of the triangle mesh (i.e., V[F] returns an array with shape
(num_faces, 3, 3) such that V[F][i] is a 3x3 matrix whose rows
are the vertices of the ith face.</p></li>
<li><p><strong>N</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>, <em>optional</em>) – An array with shape (num_faces, 3) consisting of the triangle
mesh face normals. Can be passed to specify the face normals.
Otherwise, the face normals will be computed from the cross products
of the face edges (i.e. np.cross(vi1 - vi0, vi2 - vi0) normalized).</p></li>
<li><p><strong>P</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>, <em>optional</em>) – An array with shape (num_faces, 3) consisting of the triangle
centroids. Can be optionally passed to avoid recomputing.</p></li>
<li><p><strong>A</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>, <em>optional</em>) – An array of shape (num_faces,) containing the triangle areas. Can
be optionally passed to avoid recomputing.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel.num_faces">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_faces</span></span><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel.num_faces" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel.num_verts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_verts</span></span><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel.num_verts" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel.intersect1">
<span class="sig-name descname"><span class="pre">intersect1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#TrimeshShapeModel.intersect1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel.intersect1" title="Permalink to this definition"></a></dt>
<dd><p>Trace a single ray starting from <cite>x</cite> and in the direction <cite>d</cite>.  If
there is a hit, return the index (<cite>i</cite>) of the hit and a
parameter <cite>t</cite> such that the hit point is given by <cite>x(t) = x +
t*d</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel.intersect1_2d_with_coords">
<span class="sig-name descname"><span class="pre">intersect1_2d_with_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#TrimeshShapeModel.intersect1_2d_with_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel.intersect1_2d_with_coords" title="Permalink to this definition"></a></dt>
<dd><p>Trace a single ray starting from <cite>X</cite> and in the direction <cite>D</cite>.  If
there is a hit, return the index (<cite>i</cite>) of the hit and the coordinates of
the centroid of the hit triangle <cite>X(t) = X + t*D</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.TrimeshShapeModel.intersect1_2d">
<span class="sig-name descname"><span class="pre">intersect1_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#TrimeshShapeModel.intersect1_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.TrimeshShapeModel.intersect1_2d" title="Permalink to this definition"></a></dt>
<dd><p>Trace a single ray starting from <cite>X</cite> and in the direction <cite>D</cite>.  If
there is a hit, return the index (<cite>i</cite>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.CgalTrimeshShapeModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">CgalTrimeshShapeModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#CgalTrimeshShapeModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.CgalTrimeshShapeModel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.EmbreeTrimeshShapeModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">EmbreeTrimeshShapeModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#EmbreeTrimeshShapeModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.EmbreeTrimeshShapeModel" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyRTX.core.utils_rt.RTXkernel">
<span class="sig-prename descclassname"><span class="pre">pyRTX.core.utils_rt.</span></span><span class="sig-name descname"><span class="pre">RTXkernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_origins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Embree3'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffusion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_diffuse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errorMsg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyRTX/core/utils_rt.html#RTXkernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyRTX.core.utils_rt.RTXkernel" title="Permalink to this definition"></a></dt>
<dd><p>Main ray tracing kernel wrapper supporting multiple ray tracing backends and
multi-bounce simulations.</p>
<p>This is the primary interface for performing ray tracing operations in pyRTX.
It supports various ray tracing kernels (Embree, CGAL, Native), multiple
reflection bounces, and optional diffuse scattering for realistic radiation
momentum exchange calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh_obj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.Trimesh</span></code>) – The mesh geometry to ray trace against. Must be a valid triangular mesh.</p></li>
<li><p><strong>ray_origins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_rays</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Starting positions of rays in 3D space (in same coordinate system as mesh).</p></li>
<li><p><strong>ray_directions</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N_rays</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">3)</span></code>) – Direction vectors of rays. Do not need to be normalized.</p></li>
<li><p><strong>bounces</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Number of reflection bounces to simulate. bounces=1 means direct
illumination only, bounces=2 includes one reflection, etc.</p></li>
<li><p><strong>kernel</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">'Embree3'</span></code>) – Ray tracing backend to use:
- ‘Embree3’: Intel Embree library (fastest, recommended)
- ‘Embree’ : Intel Embree library (Version 2, slower than 3)
- ‘CGAL’: CGAL AABB tree implementation (robust, slower)
- ‘Native’: Pure Python implementation (very slow, for reference only)</p></li>
<li><p><strong>diffusion</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>default</em> <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a>) – If True, compute diffuse (Lambertian) reflections in addition to
specular reflections. Only applied to the first bounce. Enables
realistic modeling of rough surfaces.</p></li>
<li><p><strong>num_diffuse</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, <em>default</em> <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>) – Number of diffuse samples per intersection point. Required if
diffusion=True. Typical values: 10-100 depending on accuracy needs.</p></li>
<li><p><strong>errorMsg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>default</em> <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a>) – If True, print warning messages when no intersections are found for
a bounce. Set to False to suppress warnings in batch processing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>index_tri_container</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List containing triangle indices for each bounce. Each element is an
array of shape (N_hits_i,) containing indices of faces hit at bounce i.
Length equals number of computed bounces (≤ bounces parameter).</p></li>
<li><p><strong>index_ray_container</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List containing ray indices for each bounce. index_ray_container[i]
maps from the original ray array to rays that hit at bounce i.</p></li>
<li><p><strong>locations_container</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List of intersection point coordinates for each bounce. Each element
has shape (N_hits_i, 3).</p></li>
<li><p><strong>ray_origins_container</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List of ray origin positions for each bounce. Note that
ray_origins_container[0] equals the input ray_origins parameter.</p></li>
<li><p><strong>ray_directions_container</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – List of ray direction vectors for each bounce. Element [0] contains
input directions, subsequent elements contain reflected directions.</p></li>
<li><p><strong>diffusion_pack</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>) – If diffusion=True, contains diffuse ray tracing results:
[index_tri_diffusion, index_ray_diffusion, ray_directions_diffusion,</p>
<blockquote>
<div><p>location_diffusion]. If diffusion=False, returns None.</p>
</div></blockquote>
</li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Algorithm Overview:
1. Initialize ray tracing kernel (Embree, CGAL, or Native)
2. For each bounce:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Add small offset to ray origins (avoids self-intersection)</p></li>
<li><p>Trace rays to find intersections</p></li>
<li><p>If no hits found, terminate and return results up to current bounce</p></li>
<li><p>Compute specular reflection directions for next bounce</p></li>
<li><p>If diffusion enabled and bounce==1, also compute diffuse reflections</p></li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>Return accumulated results for all bounces</p></li>
</ol>
<p>Performance Notes:
- Embree is typically 10-100× faster than Native for large meshes
- CGAL offers good robustness for edge cases but slower than Embree
- Diffusion increases computation by factor of num_diffuse
- Memory usage scales linearly with bounces and num_diffuse</p>
<p>Kernel-Specific Details:
- Embree/Embree3: Uses BVH acceleration, highly optimized for x86 CPUs
- CGAL: Uses AABB tree, more robust numerical handling
- Native: Pure Python/Trimesh, no special acceleration</p>
<p>The 1e-3 offset added to ray origins prevents numerical precision issues
where a reflected ray might re-intersect the same surface it just bounced
from (self-intersection artifact).</p>
</div>
<div class="admonition-examples admonition">
<p class="admonition-title">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Simple direct illumination</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">RTXkernel</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">origins</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">bounces</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;Embree3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hits</span><span class="p">,</span> <span class="n">ray_ids</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">results</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Multi-bounce with diffuse scattering</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">RTXkernel</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">origins</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">bounces</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;Embree3&#39;</span><span class="p">,</span> <span class="n">diffusion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_diffuse</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hits</span><span class="p">,</span> <span class="n">ray_ids</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">origins</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">diffuse_data</span> <span class="o">=</span> <span class="n">results</span>
</pre></div>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.pixel_plane_opt" title="pyRTX.core.utils_rt.pixel_plane_opt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pixel_plane_opt</span></code></a></dt><dd><p>Generate ray grids for illumination sources</p>
</dd>
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.compute_secondary_bounce" title="pyRTX.core.utils_rt.compute_secondary_bounce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_secondary_bounce</span></code></a></dt><dd><p>Compute reflection directions</p>
</dd>
<dt><a class="reference internal" href="#pyRTX.core.utils_rt.diffuse" title="pyRTX.core.utils_rt.diffuse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diffuse</span></code></a></dt><dd><p>Generate diffuse reflection samples</p>
</dd>
</dl>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pyRTX.core.shadow_utils.html" class="btn btn-neutral float-left" title="pyRTX.core.shadow_utils" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pyRTX.classes.html" class="btn btn-neutral float-right" title="pyRTX.classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Gael Cascioli.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>